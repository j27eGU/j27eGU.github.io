<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【题解】洛谷P12085</title>
    <link href="/2025/08/31/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%B4%9B%E8%B0%B7P12085/"/>
    <url>/2025/08/31/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%B4%9B%E8%B0%B7P12085/</url>
    
    <content type="html"><![CDATA[<p><a href="http://luogu.com.cn/problem/P12085">题目传送门</a></p><p>借鉴这篇<a href="http://luogu.com.cn/article/nhijvm3v">题解</a>，dalao%%%</p><p>如果我们真的模拟的话肯定过不了的（<a href="https://www.luogu.com.cn/record/226752537">记录</a>）。</p><p>所以我们可以使用链表+优先队列的方式，来记录这个数列。</p><p>其中的删除操作也不是让我们真的删去，用版本（version）的方式记录当前数据能不能用，不能用就弹出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">500010</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-type">int</span> n,k;<br><span class="hljs-type">int</span> a[MAXN];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LIST</span><br>&#123;<br><span class="hljs-type">int</span> pre,nxt;<br>&#125;lst[MAXN];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br><span class="hljs-type">int</span> id;<br><span class="hljs-type">int</span> val;<br><span class="hljs-type">int</span> ver;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-type">const</span> node &amp;a)<span class="hljs-type">const</span><br>&#123;<br><span class="hljs-keyword">if</span>(val==a.val)<span class="hljs-keyword">return</span> id&gt;a.id;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> val&gt;a.val;<br>&#125;<br>&#125;;<br>priority_queue &lt;node&gt; q;<br><span class="hljs-type">int</span> v[MAXN];<br><span class="hljs-type">bool</span> isdel[MAXN];<span class="hljs-comment">//是否删除</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<br><span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c))<br>&#123;<br><span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;<br>c=<span class="hljs-built_in">getchar</span>();<br>&#125;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c))<br>&#123;<br>x=x*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>;<br>c=<span class="hljs-built_in">getchar</span>();<br>&#125;<br><span class="hljs-keyword">return</span> x*f;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>)x=-x;<br><span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">10</span>)<span class="hljs-built_in">putchar</span>(x+<span class="hljs-string">&#x27;0&#x27;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">print</span>(x/<span class="hljs-number">10</span>),<span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>n=<span class="hljs-built_in">read</span>(),k=<span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>&#123;<br>a[i]=<span class="hljs-built_in">read</span>();<br>q.<span class="hljs-built_in">push</span>(&#123;i,a[i],<span class="hljs-number">0</span>&#125;);<br>lst[i]=&#123;i<span class="hljs-number">-1</span>,i<span class="hljs-number">+1</span>&#125;;<span class="hljs-comment">//链表</span><br>&#125;<br>lst[<span class="hljs-number">1</span>].pre=lst[n].nxt=<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> vers=<span class="hljs-number">1</span>;vers&lt;=k;vers++)<br>&#123;<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()&amp;&amp;q.<span class="hljs-built_in">top</span>().ver!=v[q.<span class="hljs-built_in">top</span>().id])q.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//过期的数据弹出</span><br>node front=q.<span class="hljs-built_in">top</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-type">int</span> id=front.id;<br>isdel[id]=<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> val=front.val;<br><span class="hljs-type">int</span> pre=lst[id].pre,nxt=lst[id].nxt;<br><span class="hljs-keyword">if</span>(pre!=<span class="hljs-number">-1</span>)<br>&#123;<br>lst[pre].nxt=nxt;<br>a[pre]+=val;<br>q.<span class="hljs-built_in">push</span>(&#123;pre,a[pre],vers&#125;);<br>v[pre]=vers;<br>&#125;<br><span class="hljs-keyword">if</span>(nxt!=<span class="hljs-number">-1</span>)<br>&#123;<br>lst[nxt].pre=pre;<br>a[nxt]+=val;<br>q.<span class="hljs-built_in">push</span>(&#123;nxt,a[nxt],vers&#125;);<br>v[nxt]=vers;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br><span class="hljs-keyword">if</span>(!isdel[i])<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,a[i]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【题解】洛谷P2829</title>
    <link href="/2025/08/24/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%B4%9B%E8%B0%B7P2829/"/>
    <url>/2025/08/24/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%B4%9B%E8%B0%B7P2829/</url>
    
    <content type="html"><![CDATA[<p><a href="http://luogu.com.cn/problem/p2829">题目传送门</a></p><p>这道题和<a href="https://j27egu.github.io/2025/08/23/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%B4%9B%E8%B0%B7P2865/">P2865</a>一样，都是最短路。</p><p>只是在读入时统计度数，更新时增加判断：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(v!=<span class="hljs-number">1</span>&amp;&amp;v!=n&amp;&amp;deg[v]&lt;k)<span class="hljs-keyword">continue</span>;<br></code></pre></td></tr></table></figure><p>这道题就过了。</p><p>文章最短的一次……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">5010</span>,inf=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span><br>&#123;<br>    <span class="hljs-type">int</span> v,w;<br>&#125;;<br>vector &lt;edge&gt; g[MAXN];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br>    <span class="hljs-type">int</span> u,dis;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-type">const</span> node a)<span class="hljs-type">const</span> <br>    &#123;<br>        <span class="hljs-keyword">return</span> dis&gt;a.dis;<br>    &#125;<br>&#125;;<br><span class="hljs-type">int</span> dis[MAXN],ldis[MAXN],deg[MAXN],n,m,k;<br><span class="hljs-type">bool</span> vis[MAXN][MAXN];<br>priority_queue &lt;node&gt; q;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dis,inf,<span class="hljs-built_in">sizeof</span>(dis));<br>    <span class="hljs-built_in">memset</span>(ldis,inf,<span class="hljs-built_in">sizeof</span>(ldis));<br>    dis[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;);<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        node front=q.<span class="hljs-built_in">top</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> u=front.u;<br>        <span class="hljs-keyword">if</span>(front.dis&gt;ldis[u]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;g[u].<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            <span class="hljs-type">int</span> v=g[u][i].v,w=g[u][i].w;<br>            <span class="hljs-keyword">if</span>(v!=<span class="hljs-number">1</span>&amp;&amp;v!=n&amp;&amp;deg[v]&lt;k)<span class="hljs-keyword">continue</span>;<span class="hljs-comment">//这里增加判断！！！</span><br>            <span class="hljs-keyword">if</span>(front.dis+w&lt;dis[v])<br>            &#123;<br>                ldis[v]=dis[v];<br>                dis[v]=front.dis+w;<br>                q.<span class="hljs-built_in">push</span>(&#123;v,dis[v]&#125;);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(front.dis+w&gt;dis[v]&amp;&amp;front.dis+w&lt;ldis[v])<br>            &#123;<br>                ldis[v]=front.dis+w;<br>                q.<span class="hljs-built_in">push</span>(&#123;v,ldis[v]&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>),cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> u,v,w;<br>        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;<br>        g[u].<span class="hljs-built_in">push_back</span>(&#123;v,w&#125;);<br>        g[v].<span class="hljs-built_in">push_back</span>(&#123;u,w&#125;);<br>        <span class="hljs-keyword">if</span>(!vis[u][v])<br>        &#123;<span class="hljs-comment">//这里统计度数</span><br>            <span class="hljs-comment">//vis记录这个边是否有记录过，防止重边</span><br>            vis[u][v]=vis[v][u]=<span class="hljs-number">1</span>;<br>            deg[u]++,deg[v]++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">dijkstra</span>();<br>    <span class="hljs-keyword">if</span>(ldis[n]==inf)cout&lt;&lt;<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span> cout&lt;&lt;ldis[n];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【题解】洛谷P2865</title>
    <link href="/2025/08/23/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%B4%9B%E8%B0%B7P2865/"/>
    <url>/2025/08/23/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%B4%9B%E8%B0%B7P2865/</url>
    
    <content type="html"><![CDATA[<p><a href="http://luogu.com.cn/problem/P2865">题目传送门</a></p><p>我们可以用1次dijkstra解决这个问题。</p><p>每次读入队首进行更新时有三种情况：</p><p>1.更新最短路、次短路。</p><p>2.能更新次短路，但不能更新最短路。</p><p>3.啥也不能更新。</p><p>用dis代表最短路，ldis代表次短路。</p><p>在<code>q.top().dis+w&lt;dis[v]</code>时可以更新最短路和次短路：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ldis[v]=dis[v];<br>dis[v]=q.<span class="hljs-built_in">top</span>().dis+w;<br></code></pre></td></tr></table></figure><p>在<code>q.top().dis+w&gt;dis[v]&amp;&amp;q.top().dis+w&lt;ldis[v]</code>时可以更新次短路：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ldis[v]=q.<span class="hljs-built_in">top</span>().dis+w;<br></code></pre></td></tr></table></figure><p>哦，还有判断队首节点是否要继续更新的条件也要改成</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">front.dis&gt;ldis[u]<br></code></pre></td></tr></table></figure><p>不然就会跳过更新次短路。</p><p>以下是代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">5010</span>,inf=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span><br>&#123;<br><span class="hljs-type">int</span> v,w;<br>&#125;;<br>vector &lt;edge&gt; g[MAXN];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br><span class="hljs-type">int</span> u,dis;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-type">const</span> node a)<span class="hljs-type">const</span> <br>&#123;<br><span class="hljs-keyword">return</span> dis&gt;a.dis;<br>&#125;<br>&#125;;<br><span class="hljs-type">int</span> dis[MAXN],ldis[MAXN],n,m;<br>priority_queue &lt;node&gt; q;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">memset</span>(dis,inf,<span class="hljs-built_in">sizeof</span>(dis));<br><span class="hljs-built_in">memset</span>(ldis,inf,<span class="hljs-built_in">sizeof</span>(ldis));<br>dis[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;);<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br>node front=q.<span class="hljs-built_in">top</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-type">int</span> u=front.u;<br><span class="hljs-keyword">if</span>(front.dis&gt;ldis[u])<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;g[u].<span class="hljs-built_in">size</span>();i++)<br>&#123;<br><span class="hljs-type">int</span> v=g[u][i].v,w=g[u][i].w;<br><span class="hljs-keyword">if</span>(front.dis+w&lt;dis[v])<br>&#123;<br>ldis[v]=dis[v];<br>dis[v]=front.dis+w;<br>q.<span class="hljs-built_in">push</span>(&#123;v,dis[v]&#125;);<br>&#125;<br><span class="hljs-keyword">if</span>(front.dis+w&gt;dis[v]&amp;&amp;front.dis+w&lt;ldis[v])<br>&#123;<br>ldis[v]=front.dis+w;<br>q.<span class="hljs-built_in">push</span>(&#123;v,ldis[v]&#125;);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>),cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>&#123;<br><span class="hljs-type">int</span> u,v,w;<br>cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;<br>g[u].<span class="hljs-built_in">push_back</span>(&#123;v,w&#125;);<br>g[v].<span class="hljs-built_in">push_back</span>(&#123;u,w&#125;);<br>&#125;<br><span class="hljs-built_in">dijkstra</span>();<br>cout&lt;&lt;ldis[n];<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【题解】洛谷P2704</title>
    <link href="/2025/08/21/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%B4%9B%E8%B0%B7P2704/"/>
    <url>/2025/08/21/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%B4%9B%E8%B0%B7P2704/</url>
    
    <content type="html"><![CDATA[<p><a href="http://luogu.com.cn/problem/P2704">题目传送门</a></p><p>考虑到地形可以用二进制01表示，使用状压dp。</p><p>状压dp是采用十进制数字表示二进制的状态，实现状态的压缩。</p><p>如何设计状态，dp[层数][当前行的放置炮兵的情况][上一行放置炮兵的情况。</p><p>判断炮兵的放置情况要判断下面的情况是否合法：</p><ul><li>左移右移一位两位相与的结果要为0</li><li>放置情况与地形相与的结果要为0</li></ul><p>我们可以通过下面的代码来实现记录地形（grd数组）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>    &#123;<br>        <span class="hljs-type">char</span> tmp;<br>        cin&gt;&gt;tmp;<br>        grd[i]=(grd[i]&lt;&lt;<span class="hljs-number">1</span>)+(tmp==<span class="hljs-string">&#x27;H&#x27;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>为了不误伤友军，我们需要通过二进制的左移和右移来判断是否会误伤。</p><p>我们用以下的代码，通过can数组来记录这个状态是否可用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;m);i++)<br><span class="hljs-keyword">if</span>(!(i&amp;(i&lt;&lt;<span class="hljs-number">1</span>))&amp;&amp;!(i&amp;(i&lt;&lt;<span class="hljs-number">2</span>))&amp;&amp;!(i&amp;i&gt;&gt;<span class="hljs-number">1</span>)&amp;&amp;!(i&amp;i&gt;&gt;<span class="hljs-number">2</span>))<br>&#123;<br>can[i]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>((i&amp;grd[<span class="hljs-number">1</span>])==<span class="hljs-number">0</span>)dp[<span class="hljs-number">1</span>][i][<span class="hljs-number">0</span>]=<span class="hljs-built_in">res</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们还可以顺便把dp的第一层给搞定。</p><p>res(i)是用来计算i在二进制下1的个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i)<br>&#123;<br><span class="hljs-keyword">if</span>(i&amp;<span class="hljs-number">1</span>)cnt++;<br>i&gt;&gt;=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure><p>同理，我们通过枚举上一行和当前行的状态来进行dp。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//对第二行进行dp</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> A=<span class="hljs-number">0</span>;A&lt;(<span class="hljs-number">1</span>&lt;&lt;m);A++)<br><span class="hljs-keyword">if</span>(can[A]&amp;&amp;(A&amp;grd[<span class="hljs-number">1</span>])==<span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> B=<span class="hljs-number">0</span>;B&lt;(<span class="hljs-number">1</span>&lt;&lt;m);B++)<br><span class="hljs-keyword">if</span>(can[B]&amp;&amp;(B&amp;grd[<span class="hljs-number">2</span>])==<span class="hljs-number">0</span>&amp;&amp;(A&amp;B)==<span class="hljs-number">0</span>)<br>dp[<span class="hljs-number">2</span>][B][A]=dp[<span class="hljs-number">1</span>][A][<span class="hljs-number">0</span>]+<span class="hljs-built_in">res</span>(B);<br><span class="hljs-comment">//对3~n行进行dp</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=n;i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> A=<span class="hljs-number">0</span>;A&lt;(<span class="hljs-number">1</span>&lt;&lt;m);A++)<br><span class="hljs-keyword">if</span>(can[A]&amp;&amp;(A&amp;grd[i<span class="hljs-number">-2</span>])==<span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> B=<span class="hljs-number">0</span>;B&lt;(<span class="hljs-number">1</span>&lt;&lt;m);B++)<br><span class="hljs-keyword">if</span>(can[B]&amp;&amp;(B&amp;grd[i<span class="hljs-number">-1</span>])==<span class="hljs-number">0</span>&amp;&amp;(A&amp;B)==<span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> C=<span class="hljs-number">0</span>;C&lt;(<span class="hljs-number">1</span>&lt;&lt;m);C++)<br><span class="hljs-keyword">if</span>(can[C]&amp;&amp;(C&amp;grd[i])==<span class="hljs-number">0</span>&amp;&amp;(C&amp;A)==<span class="hljs-number">0</span>&amp;&amp;(C&amp;B)==<span class="hljs-number">0</span>)<br>dp[i][C][B]=<span class="hljs-built_in">max</span>(dp[i][C][B],dp[i<span class="hljs-number">-1</span>][B][A]+<span class="hljs-built_in">res</span>(C));<br></code></pre></td></tr></table></figure><p>后面用ans统计答案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;(<span class="hljs-number">1</span>&lt;&lt;m);j++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;(<span class="hljs-number">1</span>&lt;&lt;m);k++)<br>ans=<span class="hljs-built_in">max</span>(ans,dp[i][j][k]);<br></code></pre></td></tr></table></figure><p>相信大家的拼装能力肯定不错，能够把上面这些零件拼起来的。</p><h2 id="完整答案："><a href="#完整答案：" class="headerlink" title="完整答案："></a>完整答案：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m,grd[<span class="hljs-number">110</span>],dp[<span class="hljs-number">110</span>][(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">10</span>)][(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">10</span>)];<br><span class="hljs-type">bool</span> can[(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">10</span>)];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i)<br>&#123;<br><span class="hljs-keyword">if</span>(i&amp;<span class="hljs-number">1</span>)cnt++;<br>i&gt;&gt;=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> cnt;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>),cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>&#123;<br><span class="hljs-type">char</span> tmp;<br>cin&gt;&gt;tmp;<br>grd[i]=(grd[i]&lt;&lt;<span class="hljs-number">1</span>)+(tmp==<span class="hljs-string">&#x27;H&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;m);i++)<br><span class="hljs-keyword">if</span>(!(i&amp;(i&lt;&lt;<span class="hljs-number">1</span>))&amp;&amp;!(i&amp;(i&lt;&lt;<span class="hljs-number">2</span>))&amp;&amp;!(i&amp;i&gt;&gt;<span class="hljs-number">1</span>)&amp;&amp;!(i&amp;i&gt;&gt;<span class="hljs-number">2</span>))<br>&#123;<br>can[i]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>((i&amp;grd[<span class="hljs-number">1</span>])==<span class="hljs-number">0</span>)dp[<span class="hljs-number">1</span>][i][<span class="hljs-number">0</span>]=<span class="hljs-built_in">res</span>(i);<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> A=<span class="hljs-number">0</span>;A&lt;(<span class="hljs-number">1</span>&lt;&lt;m);A++)<br><span class="hljs-keyword">if</span>(can[A]&amp;&amp;(A&amp;grd[<span class="hljs-number">1</span>])==<span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> B=<span class="hljs-number">0</span>;B&lt;(<span class="hljs-number">1</span>&lt;&lt;m);B++)<br><span class="hljs-keyword">if</span>(can[B]&amp;&amp;(B&amp;grd[<span class="hljs-number">2</span>])==<span class="hljs-number">0</span>&amp;&amp;(A&amp;B)==<span class="hljs-number">0</span>)<br>dp[<span class="hljs-number">2</span>][B][A]=dp[<span class="hljs-number">1</span>][A][<span class="hljs-number">0</span>]+<span class="hljs-built_in">res</span>(B);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=n;i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> A=<span class="hljs-number">0</span>;A&lt;(<span class="hljs-number">1</span>&lt;&lt;m);A++)<br><span class="hljs-keyword">if</span>(can[A]&amp;&amp;(A&amp;grd[i<span class="hljs-number">-2</span>])==<span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> B=<span class="hljs-number">0</span>;B&lt;(<span class="hljs-number">1</span>&lt;&lt;m);B++)<br><span class="hljs-keyword">if</span>(can[B]&amp;&amp;(B&amp;grd[i<span class="hljs-number">-1</span>])==<span class="hljs-number">0</span>&amp;&amp;(A&amp;B)==<span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> C=<span class="hljs-number">0</span>;C&lt;(<span class="hljs-number">1</span>&lt;&lt;m);C++)<br><span class="hljs-keyword">if</span>(can[C]&amp;&amp;(C&amp;grd[i])==<span class="hljs-number">0</span>&amp;&amp;(C&amp;A)==<span class="hljs-number">0</span>&amp;&amp;(C&amp;B)==<span class="hljs-number">0</span>)<br>dp[i][C][B]=<span class="hljs-built_in">max</span>(dp[i][C][B],dp[i<span class="hljs-number">-1</span>][B][A]+<span class="hljs-built_in">res</span>(C));<br><span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;(<span class="hljs-number">1</span>&lt;&lt;m);j++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;(<span class="hljs-number">1</span>&lt;&lt;m);k++)<br>ans=<span class="hljs-built_in">max</span>(ans,dp[i][j][k]);<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【学习笔记】树上差分</title>
    <link href="/2025/07/29/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86/"/>
    <url>/2025/07/29/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>1.点差分</p><p>2.边差分</p><h2 id="边差分"><a href="#边差分" class="headerlink" title="边差分"></a>边差分</h2><p>对差分和差分数组的理解一般都是停留再数组这种线性结构上，这可能会导致学习树上差分的时候无法理解这个概念。</p><p>树上差分一般应用于在树上的路径统计。</p><p>对于一棵树，可以设置差分数组表示经过边$i$（边$i$的定义是连接$i$到$i$父亲的这条边）的次数。</p><p>进行边差分是一般是从叶子节点向根节点进行差分。</p><p>若要在$(u,v)$的路径上进行加$i$，那我们要在差分数组进行下面操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">d[u]+=i,d[v]+=i,d[<span class="hljs-built_in">lca</span>(u,v)]-=<span class="hljs-number">2</span>i;<br><span class="hljs-comment">//反之</span><br>d[u]-=i,d[v]-=i,d[<span class="hljs-built_in">lca</span>(u,v)]+=<span class="hljs-number">2</span>i;<br></code></pre></td></tr></table></figure><p>任意两点之间有且只有一条简单路径。</p><p>如果是一棵无根树，那么确定根节点后，出根节点外每个点有且只有一个父节点。</p><h2 id="点差分"><a href="#点差分" class="headerlink" title="点差分"></a>点差分</h2><p>对于图上的问题，有一些问题是带边权的，有一些问题则是带点权的。</p><p>对于这些问题，可以把两种权值相互转化，即边权转点权、点权转边权等操作。</p><p>但是其实有时候完全没有必要，点的差分数组比较好定义：</p><p>$d_i$表示$i$点一共被经过几次。那么对于路径$(u,v)$，就有以下的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">d[u]+=i,d[v]+=i,d[<span class="hljs-built_in">lca</span>(u,v)]-=i,d[fa[<span class="hljs-built_in">lca</span>(u,v)]]-=i;<br><span class="hljs-comment">//反之</span><br>d[u]-=i,d[v]-=i,d[<span class="hljs-built_in">lca</span>(u,v)]+=i,d[fa[<span class="hljs-built_in">lca</span>(u,v)]]+=i;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【学习笔记】子树和</title>
    <link href="/2025/07/29/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%AD%90%E6%A0%91%E5%92%8C/"/>
    <url>/2025/07/29/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%AD%90%E6%A0%91%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在数据结构中存在一种叫“树”的结构。</p><p>树的定义：树是由$n$个节点（或元素）组成的有限集合（记为$T$）。</p><ul><li><p>如果$n&#x3D;0$，它是一棵空树。</p></li><li><p>如果$n&gt;0$，这个n个节点有且仅有一个节点作为树的根节点，简称为跟，其余节点可分为$m(m\leq 0)$个互不相干的有限集合$T1,T2\cdots$，其中，每个自己不呢神是一棵符合定义的树，成为根节点的子树。</p></li></ul><h2 id="求二叉树的最大子树和"><a href="#求二叉树的最大子树和" class="headerlink" title="求二叉树的最大子树和"></a>求二叉树的最大子树和</h2><p><a href="http://luogu.com.cn/problem/P1122">p_lnk</a></p><p>通过递归树形dp，求以$u$为根的最大值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">100010</span>;<br>vector &lt;<span class="hljs-type">int</span>&gt; g[MAXN];<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll w[MAXN],dp[MAXN];<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>dp[u]=w[u];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> v:g[u])<br>&#123;<br><span class="hljs-keyword">if</span>(v==fa)<span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">dfs</span>(v,u);<br>dp[u]+=<span class="hljs-built_in">max</span>(dp[v],<span class="hljs-number">0LL</span>);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)cin&gt;&gt;w[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)<br>&#123;<br><span class="hljs-type">int</span> u,v;<br>cin&gt;&gt;u&gt;&gt;v;<br>g[u].<span class="hljs-built_in">push_back</span>(v);<br>g[v].<span class="hljs-built_in">push_back</span>(u);<br>&#125;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>cout&lt;&lt;*<span class="hljs-built_in">max_element</span>(dp<span class="hljs-number">+1</span>,dp+n<span class="hljs-number">+1</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【学习笔记】单源次短路径</title>
    <link href="/2025/07/27/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%8D%95%E6%BA%90%E6%AC%A1%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <url>/2025/07/27/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%8D%95%E6%BA%90%E6%AC%A1%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>计算原图的最短路径，并保存路径。</p><p>即破坏最短路中的每一条边，重新计算最短路，并排序。</p><p>最短的就是单源最短路径。</p><p>方法：</p><ul><li>从起点跑一边最短路，重点跑一边最短路，然后枚举中间点。</li><li>在求最短路时顺便维护次短路径。</li></ul><h2 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h2><p>起点和终点各跑一边最短路然后枚举中间点。</p><p>先说结论，节点x到节点y的次短路可以看作</p><p><strong>$minpath&#x3D; \min {mindis(x,k1)+lengh(k1,k2)+mindisn(k2,y)}$并且$mindis \neq dis(x,y)$</strong></p><p>这里的$mindis$为$x$到割点的最短路径，$mindisn$为$y$到割点的最短路径。</p><p>也就是说，枚举每一条边，然后加上起点到这个边的一点的最短路径+终点到这个边另外一个点的最短路径，找到最小且不等于最短路径的路径即为最短路径。</p><p>起点和重点各跑一边最短路，然后枚举中间点。</p><p>但是注意，这种做法一般仅限于无向图，因为默认终点到各个点的最短路也是各个点到终点的最短路径，而且这种方式还是比较消耗时间的，毕竟要跑两遍最短路。</p><h2 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h2><p>要对一个有向有权图（无向图每条边可以看作两条相反的有向边）的顶点$S$到$T$之间求次短路径。</p><p>首先应求出$S$的单源最短路径。</p><p>遍历有向图，标记出可以在最短路径上的边，加入集合$K$。</p><p>然后枚举删除集合K中的每一个边，求$S$到$T$的最短路径。</p><p>记录每次求出的路径长度值，其最小就是次短路径的长度。</p><p>在这里规定次短路径长度可以等于最短路径长度，如果相等，也可以看作时从S到T有布置一条最短路径。</p><p>如果规定求从$S$到$T$最短路径长度的次短路径，则答案时每次删边后大于最短路径的$S$到$T$的最短路径长度的最小值。</p><p>用dijkstra+堆求单源最短路径，则每次求最短路径时间复杂度为$O(n \log(n+m)+M)$，所以总的时间复杂度为$O(n\ m\  \log(n+m)+m^2)$。</p><p>该估计是较为悲观的，因为一般来说，在最短路径上的边的条数远远小于$M$，所以实际效果要比预想的好。</p><p><a href="http://j27egu.github.io/2025/08/23/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%B4%9B%E8%B0%B7P2865">代码在这里</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【学习笔记】线段树</title>
    <link href="/2025/07/25/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <url>/2025/07/25/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>线段树是一种二叉搜索树，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶子节点。</p><p>使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度未$O(\log n)$。而未优化的空间复杂度为$2N$，实际应用是一般还要开$4N$，的数组以免越界，因此有时需要离散化让空间压缩。</p><p>树的形态一般如下：（引用自OI-WIKI）</p><img src="https://oi-wiki.org/ds/images/segt1.svg" style="zoom:50%;" /><p>对于线段树中的每一个非叶子节点$[a,b]$，它的左儿子表示区间为$[a,\frac{a+b}{2}]$，它的右儿子表示的区间为$[\frac{a+b}{2}+1,b]$。因此线段树是平衡二叉树，最后的子节点数目为$N$，即整个线段区间的长度。</p><p>使用线段树可以快速查找某一个节点在若干条线段中出现的次数，时间复杂度为$O(\log 2n)$。而为优化的空间复杂度为$T(2N)$，因此有时需要离散化进行空间压缩。</p><p>图片举例（引用自CSDN la_alweq）</p><p>每个节点存什么，节点下标是什么，如何建树？</p><p><a href="https://i-blog.csdnimg.cn/blog_migrate/8e64e93c7a590efe8490c43c052406df.png">pic_lnk</a></p><img src="https://i-blog.csdnimg.cn/blog_migrate/8e64e93c7a590efe8490c43c052406df.png" style="zoom:50%;" /><p>该数组为$a&#x3D;{1,8,6,4,3,5}$，红色代表节点存储的区间，蓝色表示该区间内的最大值。</p><p>每个叶子节点的值，就是数组的值，每个非叶子节点的度都为二，且左右两个孩子分别存储父亲一般的区间。</p><p>每个父亲存储的值也就是两个孩子存储的值的最大值。</p><p>如何快速找到非叶子节点的孩子以及非根节点的父亲？</p><p>对于一个区间$[l,r]$来说，最重要的数据当然就是区间的做右端点$l$和$r$，但是大部分的情况我们并不会去存储这两个数值，而是通过递归的传参方式进行传递。</p><p>这种方式用指针很好实现，定义两个左右子树递归即可，但是指针表示过于繁琐，而且不方便各种操作，大部分线段树都是使用数组进行表示，快速使用下标找到左右子树。</p><p>图片举例（引用自CSDN la_alweq）</p><p><a href="https://i-blog.csdnimg.cn/blog_migrate/3e23057c9052f59c9a96cb7373d71b37.png">pic_lnk</a></p><img src="https://i-blog.csdnimg.cn/blog_migrate/3e23057c9052f59c9a96cb7373d71b37.png" style="zoom:50%;" /><p>其中的绿色是下表编号。</p><p>在最下排的编号从$9$直接到$12$，中间其实有两个空间。虽然没有使用，但还是存在。所以无优化的线段树开到$4N$才能防止RE。</p><p>每个父亲和孩子下标的关系如下：</p><ul><li>每个左子树的下标都是偶数，右子树的下标都是奇数。</li><li>父亲节点是儿子节点的一半，向下取整。</li><li>儿子节点是父亲节点的两倍，或加一。</li></ul><p>把线段树看作一个完全二叉树，空节点也当作使用。</p><p>根据奇怪的规律<del>（不支持md所以省略）</del>很简单就得到右子树节点为左子树节点数加一。</p><p><del>（这一段是什么用处呢？）</del></p><p>因为左子树都是偶数，所以我们常用位运算来寻寻找左右子树。</p><ul><li>k&lt;&lt;1，节点$k$的左子树下标。</li><li>k&lt;&lt;1|1，节点$k$的右子树下标。</li></ul><p>假如要修改$a[3]$，则包含此值的节点都需要更新。</p><p>根据二叉树的性质，$\log k$个节点都需要进行更新，这也正是为什么每次更新的时间复杂度为$O(\log n)$。</p><p>可以发现无论更新那个叶子节点，最终都会回到根节点，而把这个往上推的过程逆过来就是从根节点进行递归处理。</p><p>以下面的图为例（引用自CSDN la_alweq）</p><p><a href="https://i-blog.csdnimg.cn/blog_migrate/f2de351965c5ecdab7a635025be5de68.png">pic_lnk</a></p><img src="https://i-blog.csdnimg.cn/blog_migrate/f2de351965c5ecdab7a635025be5de68.png" style="zoom:50%;" /><p>线段树的每个节点存储的都是一段区间的信息，如果刚好要查询这个节点，那么则直接返回这个节点的信息即可，比如直接查询$[1,6]$这个区间的最值，那么直接返回根节点信息$13$。</p><p>若要查询区间$[2,5]$，那我们只需要查询$[2,2]，[3,3]，[4,5]$，三个区间。$[4,4]，[5,5]$不需要查找，包含在$[4,5]$中了。</p><p>$[2,5]$一共五个区间，而且发现$[4,5]$这个区间已经包含了$[4,4]，[5,5]$两个子树的信息，所以需要查询的区间只有三个，是$[2,2]，[3,3]，[4,5]$。</p><p>可以通过更新的思路想出来查询的思路，从根节点开始往下递归，时间复杂度$O(\log n)$。</p><p>线段树的区间更新使用差分的思想。</p><p>传统上，对于区间$[l,r]$，可能每次都更新区间中的每个值，更新的复杂度将会是$O(n\log n)$，造成浪费。</p><p>在进行区间更新是，引用lazy标记，提高更新的效率。</p><p>如果当前区间被需要修改的目标区间完全覆盖，则在被更新节点上打lazy标记，此区间不向下传导，这样的搭配使区间更新的操作和区间查询类似，复杂度为$O(\log n)$。</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【题解】洛谷P7775</title>
    <link href="/2025/07/23/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%B4%9B%E8%B0%B7P7775/"/>
    <url>/2025/07/23/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%B4%9B%E8%B0%B7P7775/</url>
    
    <content type="html"><![CDATA[<p>感谢@<a href="https://www.luogu.com.cn/user/1392775">xiejinghan</a><del>在赛时</del>给我分享思路。</p><p><a href="http://luogu.com.cn/problem/P7775">题目传送门</a></p><h2 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h2><p>在一个二维矩阵上面，从<code>V</code>到<code>J</code>的路径中，求离<code>+</code>的最短距离。</p><h2 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h2><p>题目中写<code>离它最近的树的距离的最小值</code>，很明显就能想到二分。</p><p>在读入数据时，用<code>startx</code>和<code>starty</code>标记起点的坐标。</p><p>同时，用<code>endx</code>和<code>endy</code>标记窝的坐标。</p><p>这里$dtt_{i,j}$表示$i,j$到树的最短距离</p><p>接着，使用bfs的方式，对$dtt$进行处理。</p><p>（顾名思义，$dtt_{i,j}$就是坐标$i,j$的点到最近的一棵树的最短距离）</p><p>然后特判，如果起点和窝的位置重合，就直接输出$dtt_{startx,starty}$。</p><p>接下来使用二分的技巧，$l&#x3D;0,r&#x3D;1000$，然后while循环二分查找直到$l \geq r$。</p><p>如何查找？</p><p>就是用双向广搜，也就是从起点和窝同时进行广搜。</p><p>在进行双向bfs的过程中，vis的状态变成了$0,1,2$。</p><p>其中的$0$表示没有访问到，$1$表示这是起点过来访问到的，$2$表示窝过来访问到的。</p><p>bfs直到下一个点的状态（$vis_{nx,ny}$）与当前点的状态（$vis_{x,y}$）不相同，返回$1$。</p><p>（在这之前一定要判断$vis_{nx,ny} \neq 0$）</p><p>否则返回$0$。</p><h2 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">510</span>;<br><span class="hljs-type">int</span> n,m,dis_to_tree[MAXN][MAXN],startx,starty,endx,endy;<br><span class="hljs-type">int</span> vis[MAXN][MAXN];<br><span class="hljs-type">char</span> mp[MAXN][MAXN];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br><span class="hljs-type">int</span> x,y,to_tree_dis,type;<br>&#125;;<br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;,dy[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">search1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">memset</span>(dis_to_tree,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(dis_to_tree));<br><span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vis));<br>queue&lt;node&gt; q;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>&#123;<br><span class="hljs-keyword">if</span>(mp[i][j]==<span class="hljs-string">&#x27;+&#x27;</span>)<br>&#123;<br>dis_to_tree[i][j]=<span class="hljs-number">0</span>;<br>vis[i][j]=<span class="hljs-number">1</span>;<br>q.<span class="hljs-built_in">push</span>(&#123;i,j,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br>node top=q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-type">int</span> x=top.x,y=top.y;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<br>&#123;<br><span class="hljs-type">int</span> nx=x+dx[i],ny=y+dy[i];<br><span class="hljs-keyword">if</span>(nx&gt;=<span class="hljs-number">1</span>&amp;&amp;ny&gt;=<span class="hljs-number">1</span>&amp;&amp;nx&lt;=n&amp;&amp;ny&lt;=m&amp;&amp;!vis[nx][ny])<br>&#123;<br>dis_to_tree[nx][ny]=top.to_tree_dis<span class="hljs-number">+1</span>;<br>vis[nx][ny]=<span class="hljs-number">1</span>;<br>q.<span class="hljs-built_in">push</span>(&#123;nx,ny,dis_to_tree[nx][ny],<span class="hljs-number">0</span>&#125;);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> dis)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(dis==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vis));<br>queue&lt;node&gt; q;<br><span class="hljs-keyword">if</span>(dis_to_tree[startx][starty]&lt;dis||dis_to_tree[endx][endy]&lt;dis) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>q.<span class="hljs-built_in">push</span>(&#123;startx,starty,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;);<br>q.<span class="hljs-built_in">push</span>(&#123;endx,endy,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>&#125;);<br>vis[startx][starty]=<span class="hljs-number">1</span>;<br>vis[endx][endy]=<span class="hljs-number">2</span>;<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br>node top=q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-type">int</span> x=top.x,y=top.y;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<br>&#123;<br><span class="hljs-type">int</span> nx=x+dx[i],ny=y+dy[i];<br><span class="hljs-keyword">if</span>(nx&lt;<span class="hljs-number">1</span>||ny&lt;<span class="hljs-number">1</span>||nx&gt;n||ny&gt;m) <span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span>(dis_to_tree[nx][ny]&lt;dis) <span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span>(!vis[nx][ny])<br>&#123;<br>vis[nx][ny]=top.type;<br>q.<span class="hljs-built_in">push</span>(&#123;nx,ny,<span class="hljs-number">0</span>,top.type&#125;);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(vis[nx][ny]!=top.type)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>&#123;<br>cin&gt;&gt;mp[i][j];<br><span class="hljs-keyword">if</span>(mp[i][j]==<span class="hljs-string">&#x27;V&#x27;</span>) startx=i,starty=j;<br><span class="hljs-keyword">if</span>(mp[i][j]==<span class="hljs-string">&#x27;J&#x27;</span>) endx=i,endy=j;<br>&#125;<br>&#125;<br><span class="hljs-built_in">search1</span>();<br><span class="hljs-keyword">if</span>(startx==endx&amp;&amp;starty==endy)<br>&#123;<br>cout&lt;&lt;dis_to_tree[startx][starty]&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=<span class="hljs-number">1000</span>;<br><span class="hljs-keyword">while</span>(l&lt;r)<br>&#123;<br><span class="hljs-type">int</span> mid=(l+r<span class="hljs-number">+1</span>)&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">solve</span>(mid)) l=mid;<br><span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;<br>&#125;<br>cout&lt;&lt;l&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
