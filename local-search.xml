<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【学习笔记】树上差分</title>
    <link href="/2025/07/29/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86/"/>
    <url>/2025/07/29/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>1.点差分</p><p>2.边差分</p><h2 id="边差分"><a href="#边差分" class="headerlink" title="边差分"></a>边差分</h2><p>对差分和差分数组的理解一般都是停留再数组这种线性结构上，这可能会导致学习树上差分的时候无法理解这个概念。</p><p>树上差分一般应用于在树上的路径统计。</p><p>对于一棵树，可以设置差分数组表示经过边i（边i的定义是连接i到i父亲的这条边）的次数。</p><p>进行边差分是一般是从叶子节点向根节点进行差分。</p><p>若要在(u,v)的路径上进行加i，那我们要在差分数组进行下面操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">d[u]+=i,d[v]+=i,d[<span class="hljs-built_in">lca</span>(u,v)]-=<span class="hljs-number">2</span>i;<br><span class="hljs-comment">//反之</span><br>d[u]-=i,d[v]-=i,d[<span class="hljs-built_in">lca</span>(u,v)]+=<span class="hljs-number">2</span>i;<br></code></pre></td></tr></table></figure><p>任意两点之间有且只有一条简单路径。</p><p>如果是一棵无根树，那么确定根节点后，出根节点外每个点有且只有一个父节点。</p><h2 id="点差分"><a href="#点差分" class="headerlink" title="点差分"></a>点差分</h2><p>对于图上的问题，有一些问题是带边权的，有一些问题则是带点权的。</p><p>对于这些问题，可以把两种权值相互转化，即边权转点权、点权转边权等操作。</p><p>但是其实有时候完全没有必要，点的差分数组比较好定义：</p><p>d[i]表示i点一共被经过几次。那么对于路径(u,v)，就有以下的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">d[u]+=i,d[v]+=i,d[<span class="hljs-built_in">lca</span>(u,v)]-=i,d[fa[<span class="hljs-built_in">lca</span>(u,v)]]-=i;<br><span class="hljs-comment">//反之</span><br>d[u]-=i,d[v]-=i,d[<span class="hljs-built_in">lca</span>(u,v)]+=i,d[fa[<span class="hljs-built_in">lca</span>(u,v)]]+=i;<br></code></pre></td></tr></table></figure><p><a href="http://luogu.com.cn/problem/P1660">p_lnk</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【学习笔记】子树和</title>
    <link href="/2025/07/29/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%AD%90%E6%A0%91%E5%92%8C/"/>
    <url>/2025/07/29/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%AD%90%E6%A0%91%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在数据结构中存在一种叫“树”的结构。</p><p>树的定义：树是由n个节点（或元素）组成的有限集合（记为T）。</p><ul><li><p>如果n&#x3D;0，它是一棵空树。</p></li><li><p>如果n&gt;0，这个n个节点有且仅有一个节点作为树的根节点，简称为跟，其余节点可分为m(m&gt;&#x3D;0)个互不相干的有限集合T1,T2….，其中，每个自己不呢神是一棵符合定义的树，成为根节点的子树。</p></li></ul><h2 id="求二叉树的最大子树和"><a href="#求二叉树的最大子树和" class="headerlink" title="求二叉树的最大子树和"></a>求二叉树的最大子树和</h2><p><a href="http://luogu.com.cn/problem/P1122">p_lnk</a></p><p>通过递归树形dp，求以u为根的最大值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">100010</span>;<br>vector &lt;<span class="hljs-type">int</span>&gt; g[MAXN];<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll w[MAXN],dp[MAXN];<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>dp[u]=w[u];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> v:g[u])<br>&#123;<br><span class="hljs-keyword">if</span>(v==fa)<span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">dfs</span>(v,u);<br>dp[u]+=<span class="hljs-built_in">max</span>(dp[v],<span class="hljs-number">0LL</span>);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)cin&gt;&gt;w[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)<br>&#123;<br><span class="hljs-type">int</span> u,v;<br>cin&gt;&gt;u&gt;&gt;v;<br>g[u].<span class="hljs-built_in">push_back</span>(v);<br>g[v].<span class="hljs-built_in">push_back</span>(u);<br>&#125;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>cout&lt;&lt;*<span class="hljs-built_in">max_element</span>(dp<span class="hljs-number">+1</span>,dp+n<span class="hljs-number">+1</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【学习笔记】单源次短路径</title>
    <link href="/2025/07/27/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%8D%95%E6%BA%90%E6%AC%A1%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <url>/2025/07/27/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%8D%95%E6%BA%90%E6%AC%A1%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h1 id="单源次短路径"><a href="#单源次短路径" class="headerlink" title="单源次短路径"></a>单源次短路径</h1><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>计算原图的最短路径，并保存路径。</p><p>即破坏最短路中的每一条边，重新计算最短路，并排序。</p><p>最短的就是单源最短路径。</p><p>方法：</p><ul><li>从起点跑一边最短路，重点跑一边最短路，然后枚举中间点。</li><li>在求最短路时顺便维护次短路径。</li></ul><h2 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h2><p>起点和重点各跑一边最短路然后枚举中间点。</p><p>先说结论，节点x到节点y的次短路可以看作</p><p><strong>minpath&#x3D;min{mindis(x,k1)+length(k1,k2)+mindisn(k2,y)}并且mindis!&#x3D;dis(x,y)</strong>。</p><p>这里的mindis为x到割点的最短路径，mindisn为y到割点的最短路径。</p><p>也就是说，枚举每一条边，然后加上起点到这个边的一点的最短路径+终点到这个边另外一个点的最短路径，找到最小且不等于最短路径的路径即为最短路径。</p><p>起点和重点各跑一边最短路，然后枚举中间点。</p><p>但是注意，这种做法一般仅限于无向图，因为默认终点到各个点的最短路也是各个点到终点的最短路径，而且这种方式还是比较消耗时间的，毕竟要跑两遍最短路。</p><p>《代码略，没看到……》</p><h2 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h2><p>要对一个有向有权图（无向图每条边可以看作两条相反的有向边）的顶点S到T之间求次短路径。</p><p>首先应求出S的单源最短路径。</p><p>遍历有向图，标记出可以在最短路径上的边，加入集合K。</p><p>然后枚举删除集合K中的每一个边，求S到T的最短路径。</p><p>记录每次求出的路径长度值，其最小就是次短路径的长度。</p><p>在这里规定次短路径长度可以等于最短路径长度，如果相等，也可以看作时从S到T有布置一条最短路径。</p><p>如果规定求从S到T最短路径长度的次短路径，则答案时每次删边后大于最短路径的S到T的最短路径长度的最小值。</p><p>用dijkstra+堆求单源最短路径，则每次求最短路径时间复杂度为O(N*log(N+M)+M)，所以总的时间复杂度为O(N *M*log(N+M)+M^2)。</p><p>该估计是较为悲观的，因为一般来说，在最短路径上的边的条数远远小于M，所以实际效果要比预想的好。</p><p>《同理，没看到……》</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【题解】洛谷P1729</title>
    <link href="/2025/07/25/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%B4%9B%E8%B0%B7P1729/"/>
    <url>/2025/07/25/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%B4%9B%E8%B0%B7P1729/</url>
    
    <content type="html"><![CDATA[<p>由于我不会写高精度，只好打表。</p><p><a href="https://www.cnblogs.com/Xsmyy/p/13458500.html">lnk</a></p><p>（正好有一篇博客就是记录e的10000位，直接ctrl+c，ctrl+v！）</p><p>可谓：</p><blockquote><p>小巧玲珑，短小精悍。</p></blockquote><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>string s=<span class="hljs-string">&quot;7182818284590452353602874713526624977572470936999595749669676277240766303535475945713821785251664274274663919320030599218174135966290435729003342952605956307381323286279434907632338298807531952510190115738341879307021540891499348841675092447614606680822648001684774118537423454424371075390777449920695517027618386062613313845830007520449338265602976067371132007093287091274437470472306969772093101416928368190255151086574637721112523897844250569536967707854499699679468644549059879316368892300987931277361782154249992295763514822082698951936680331825288693984964651058209392398294887933203625094431173012381970684161403970198376793206832823764648042953118023287825098194558153017567173613320698112509961818815930416903515988885193458072738667385894228792284998920868058257492796104841984443634632449684875602336248270419786232090021609902353043699418491463140934317381436405462531520961836908887070167683964243781405927145635490613031072085103837505101157477041718986106873969655212671546889570350354021234078498193343210681701210056278802351930332247450158539047304199577770935036604169973297250886876966403555707162268447162560798826517871341951246652010305921236677194325278675398558944896970964097545918569563802363701621120477427228364896134225164450781824423529486363721417402388934412479635743702637552944483379980161254922785092577825620926226483262779333865664816277251640191059004916449982893150566047258027786318641551956532442586982946959308019152987211725563475463964479101459040905862984967912874068705048958586717479854667757573205681288459205413340539220001137863009455606881667400169842055804033637953764520304024322566135278369511778838638744396625322498506549958862342818997077332761717839280349465014345588970719425863987727547109629537415211151368350627526023264847287039207643100595841166120545297030236472549296669381151373227536450988890313602057248176585118063036442812314965507047510254465011727211555194866850800368532281831521960037356252794495158284188294787610852639813955990067376482922443752871846245780361929819713991475644882626039033814418232625150974827987779964373089970388867782271383605772978824125611907176639465070633045279546618550966661856647097113444740160704626215680717481877844371436988218559670959102596862002353718588748569652200050311734392073211390803293634479727355955277349071783793421637012050054513263835440001863239914907054797780566978533580489669062951194324730995876552368128590413832411607226029983305353708761389396391779574540161372236187893652605381558415871869255386061647798340254351284396129460352913325942794904337299085731580290958631382683291477116396337092400316894586360606458459251269946557248391865642097526850823075442545993769170419777800853627309417101634349076964237222943523661255725088147792231519747780605696725380171807763603462459278778465850656050780844211529697521890874019660906651803516501792504619501366585436632712549639908549144200014574760819302212066024330096412704894390397177195180699086998606636583232278709376502260149291011517177635944602023249300280401867723910288097866605651183260043688508817157238669842242201024950551881694803221002515426494639812873677658927688163598312477886520141174110913601164995076629077943646005851941998560162647907615321038727557126992518275687989302761761146162549356495903798045838182323368612016243736569846703785853305275833337939907521660692380533698879565137285593883499894707416181550125397064648171946708348197214488898790676503795903669672494992545279033729636162658976039498576741397359441023744329709355477982629614591442936451428617158587339746791897571211956187385783644758448423555581050025611492391518893099463428413936080383091662818811503715284967059741625628236092168075150177725387402564253470879089137291722828611515915683725241630772254406337875931059826760944203261924285317018781772960235413060672136046000389661093647095141417185777014180606443636815464440053316087783143174440811949422975599314011888683314832802706553833004693290115744147563139997221703804617092894579096271662260740718749975359212756084414737823303270330168237193648002173285734935947564334129943024850235732214597843282641421684878721673367010615094243456984401873312810107945127223737886126058165668053714396127888732527373890392890506865324138062796025930387727697783792868409325365880733988457218746021005311483351323850047827169376218004904795597959290591655470505777514308175112698985188408718564026035305583737832422924185625644255022672155980274012617971928047139600689163828665277009752767069777036439260224372841840883251848770472638440379530166905465937461619323840363893131364327137688841026811219891275223056256756254701725086349765367288605966752740868627407912856576996313789753034660616669804218267724560530660773899624218340859882071864682623215080288286359746839654358856685503773131296587975810501214916207656769950659715344763470320853215603674828608378656803073062657633469774295634643716709397193060876963495328846833613038829431040800296873869117066666146800015121143442256023874474325250769387077775193299942137277211258843608715834835626961661980572526612206797540621062080649882918454395301529982092503005498257043390553570168653120526495614857249257386206917403695213533732531666345466588597286659451136441370331393672118569553952108458407244323835586063106806964924851232632699514603596037297253198368423363904632136710116192821711150282801604488058802382031981493096369596735832742024988245684941273860566491352526706046234450549227581151709314921879592718001940968866986837037302200475314338181092708030017205935530520700706072233999463990571311587099635777359027196285061146514837526209565346713290025994397663114545902685898979115837093419370441155121920117164880566945938131183843765620627846310490346293950029458341164824114969758326011800731699437393506966295712410273239138741754923071862454543222039552735295240245903805744502892246886285336542213815722131163288112052146489805180092024719391710555390113943316681515828843687606961102505171007392762385553386272553538830960671644662370922646809671254061869502143176211668140097595281493907222601112681153108387317617323235263605838173151034595736538223534992935822836851007810884634349983518404451704270189381994243410090575376257767571118090088164183319201962623416288166521374717325477727783488774366518828752156685719506371936565390389449366421764003121527870222366463635755503565576948886549500270853923617105502131147413744106134445544192101336172996285694899193369184729478580729156088510396781959429833186480756083679551496636448965592948187851784038773326247051945050419847742014183947731202815886845707290544057510601285258056594703046836344592652552137008068752009593453607316226118728173928074623094685367823106097921599360019946237993434210687813497346959246469752506246958616909178573976595199392993995567542714654910456860702099012606818704984178079173924071945996323060254707901774527513186809982284730860766536866855516467702911336827563107223346726113705490795365834538637196235856312618387156774118738527722922594743373785695538456246801013905727871016512966636764451872465653730402443684140814488732957847348490003019477888020460324660842875351848364959195082888323206522128104190448047247949291342284951970022601310430062410717971502793433263407995960531446053230488528972917659876016667811937932372453857209607582277178483361613582612896226118129455927462767137794487586753657544861407611931125958512655759734573015333642630767985443385761715333462325270572005303988289499034259566232975782488735029259166825894456894655992658454762694528780516501720674785417887982276806536650641910973434528878338621726156269582654478205672987756426325321594294418039943217000090542650763095588465895171709147607437136893319469090981904501290307099566226620303182649365733698419555776963787624918852865686607600566025605445711337286840205574416030837052312242587223438854123179481388550075689381124935386318635287083799845692619981794523364087429591180747453419551420351726184200845509170845682368200897739455842679214273477560879644279202708312150156406341341617166448069815483764491573900121217041547872591998943825364950514771379399147205219529079396137621107238494290616357604596231253506068537651423115349665683715116604220796394466621163255157729070978473156278277598788136491951257483328793771571459091064841642678309949723674420175862269402159407924480541255360431317992696739157542419296607312393763542139230617876753958711436104089409966089471418340698362993675362621545247298464213752891079884381306095552622720837518629837066787224430195793793786072107254277289071732854874374355781966511716618330881129120245204048682200072344035025448202834254187884653602591506445271657700044521097735585897622655484941621714989532383421600114062950718490427789258552743035221396835679018076406042138307308774460170842688272261177180842664333651780002171903449234264266292261456004337383868335555343453004264818473989215627086095650629340405264943244261445665921291225648893569655009154306426134252668472594914314239398845432486327461842846655985332312210466259890141712103446084271616619001257195870793217569698544013397622096749454185407118446433946990162698351607848924514058940946395267807354579700307051163682519487701189764002827648414160587206184185297189154019688253289309149665345753571427318482016384644832499037886069008072709327673127581966563941148961716832980455139729506687604740915420428429993541025829113502241690769431668574242522509026939034814856451303069925199590436384028429267412573422447765584177886171737265462085498294498946787350929581652632072258992368768457017823038096567883112289305809140572610865884845873101658151167533327674887014829167419701512559782572707406431808601428149024146780472327597684269633935773542930186739439716388611764209004068663398856841681003872389214483176070116684503887212364367043314091155733280182977988736590916659612402021778558854876176161989370794380056663364884365089144805571039765214696027662583599051987042300179465536788&quot;</span>;<br><span class="hljs-type">int</span> n;<br>cin&gt;&gt;n;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;2.\n&quot;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>&#123;<br>cout&lt;&lt;s[i<span class="hljs-number">-1</span>];<br><span class="hljs-keyword">if</span>(i%<span class="hljs-number">50</span>==<span class="hljs-number">0</span>)<span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i%<span class="hljs-number">10</span>==<span class="hljs-number">0</span>)<span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>非常不推荐这种做法，<del>（但是我还是赛时用了o(<em>￣▽￣</em>)ブ）</del></p>]]></content>
    
    
    
    <tags>
      
      <tag>休闲娱乐</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【学习笔记】线段树</title>
    <link href="/2025/07/25/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <url>/2025/07/25/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><p>线段树是一种二叉搜索树，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶子节点。</p><p>使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度未O(log N)。而未优化的空间复杂度为2N，实际应用是一般还要开4N，的数组以免越界，因此有时需要离散化让空间压缩。</p><p>树的形态一般如下：（引用自OI-WIKI）</p><img src="https://oi-wiki.org/ds/images/segt1.svg" style="zoom:50%;" /><p>对于线段树中的每一个非叶子节点[a,b]，它的左儿子表示区间为[a,(a+b)&#x2F;2]，它的右儿子表示的区间为[(a+b)&#x2F;2+1,b]。因此线段树是平衡二叉树，最后的子节点数目为N，即整个线段区间的长度。</p><p>使用线段树可以快速查找某一个节点在若干条线段中出现的次数，时间复杂度为O(log 2N)。而为优化的空间复杂度为T(2N)，因此有时需要离散化进行空间压缩。</p><p>图片举例（引用自CSDN la_alweq）</p><p>每个节点存什么，节点下标是什么，如何建树？</p><p><a href="https://i-blog.csdnimg.cn/blog_migrate/8e64e93c7a590efe8490c43c052406df.png">pic_lnk</a></p><img src="https://i-blog.csdnimg.cn/blog_migrate/8e64e93c7a590efe8490c43c052406df.png" style="zoom:50%;" /><p>该数组为a&#x3D;{1,8,6,4,3,5}，红色代表节点存储的区间，蓝色表示该区间内的最大值。</p><p>每个叶子节点的值，就是数组的值，每个非叶子节点的度都为二，且左右两个孩子分别存储父亲一般的区间。</p><p>每个父亲存储的值也就是两个孩子存储的值的最大值。</p><p>如何快速找到非叶子节点的孩子以及非根节点的父亲？</p><p>对于一个区间[l,r]来说，最重要的数据当然就是区间的做右端点l和r，但是大部分的情况我们并不会去存储这两个数值，而是通过递归的传参方式进行传递。</p><p>这种方式用指针很好实现，定义两个左右子树递归即可，但是指针表示过于繁琐，而且不方便各种操作，大部分线段树都是使用数组进行表示，快速使用下标找到左右子树。</p><p>图片举例（引用自CSDN la_alweq）</p><p><a href="https://i-blog.csdnimg.cn/blog_migrate/3e23057c9052f59c9a96cb7373d71b37.png">pic_lnk</a></p><img src="https://i-blog.csdnimg.cn/blog_migrate/3e23057c9052f59c9a96cb7373d71b37.png" style="zoom:50%;" /><p>其中的绿色是下表编号。</p><p>在最下排的编号从9直接到12，中间其实有两个空间。虽然没有使用，但还是存在。所以无优化的线段树开到4N才能防止RE。</p><p>每个父亲和孩子下标的关系如下：</p><ul><li>每个左子树的下标都是偶数，右子树的下标都是奇数。</li><li>父亲节点是儿子节点的一半，向下取整。</li><li>儿子节点是父亲节点的两倍，或加一。</li></ul><p>把线段树看作一个完全二叉树，空节点也当作使用。</p><p>根据奇怪的规律<del>（不支持md所以省略）</del>很简单就得到右子树节点为左子树节点数加一。</p><p><del>（这一段是什么用处呢？）</del></p><p>因为左子树都是偶数，所以我们常用位运算来寻寻找左右子树。</p><ul><li>k&lt;&lt;1，节点$k$的左子树下标。</li><li>k&lt;&lt;1|1，节点$k$的右子树下标。</li></ul><p>假如要修改a[3]，则包含此值的节点都需要更新。</p><p>根据二叉树的性质，log(k)个节点都需要进行更新，这也正是为什么每次更新的时间复杂度为O(log N)。</p><p>可以发现无论更新那个叶子节点，最终都会回到根节点，而把这个往上推的过程逆过来就是从根节点进行递归处理。</p><p>以下面的图为例（引用自CSDN la_alweq）</p><p><a href="https://i-blog.csdnimg.cn/blog_migrate/f2de351965c5ecdab7a635025be5de68.png">pic_lnk</a></p><img src="https://i-blog.csdnimg.cn/blog_migrate/f2de351965c5ecdab7a635025be5de68.png" style="zoom:50%;" /><p>线段树的每个节点存储的都是一段区间的信息，如果刚好要查询这个节点，那么则直接返回这个节点的信息即可，比如直接查询[1,6]这个区间的最值，那么直接返回根节点信息13。</p><p>若要查询区间[2,5]，那我们只需要查询[2,2]，[3,3]，[4,5]，三个区间。[4,4]，[5,5]不需要查找，包含在[4,5]中了。</p><p>[2,5]一共五个区间，而且发现[4,5]这个区间已经包含了[4,4]，[5,5]两个子树的信息，所以需要查询的区间只有三个，是[2,2]，[3,3]，[4,5]。</p><p>可以通过更新的思路想出来查询的思路，从根节点开始往下递归，时间复杂度O(logN)。</p><p>线段树的区间更新使用差分的思想。</p><p>传统上，对于区间[l,r]，可能每次都更新区间中的每个值，更新的复杂度将会是O(N log N)，造成浪费。</p><p>在进行区间更新是，引用lazy标记，提高更新的效率。</p><p>如果当前区间被需要修改的目标区间完全覆盖，则在被更新节点上打lazy标记，此区间不向下传导，这样的搭配使区间更新的操作和区间查询类似，复杂度为O(log N)。</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【题解】洛谷P7775</title>
    <link href="/2025/07/23/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%B4%9B%E8%B0%B7P7775/"/>
    <url>/2025/07/23/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%B4%9B%E8%B0%B7P7775/</url>
    
    <content type="html"><![CDATA[<p>感谢@<a href="https://www.luogu.com.cn/user/1392775">xiejinghan</a><del>在赛时</del>给我分享思路。</p><p>题目链接：<a href="http://luogu.com.cn/problem/P7775">lnk</a></p><h1 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h1><p>在一个二维矩阵上面，从<code>V</code>到<code>J</code>的路径中，求离<code>+</code>的最短距离。</p><h1 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h1><p>题目中写<code>离它最近的树的距离的最小值</code>，很明显就能想到二分。</p><p>在读入数据时，用<code>startx</code>和<code>starty</code>标记起点的坐标。</p><p>同时，用<code>endx</code>和<code>endy</code>标记窝的坐标。</p><p>接着，使用bfs的方式，对<code>dis_to_tree</code>进行处理。</p><p>（顾名思义，dis_to_tree[i][j]就是坐标[i][j]的点到最近的一棵树的最短距离）</p><p>然后特判，如果起点和窝的位置重合，就直接输出dis_to_tree[startx][starty]。</p><p>接下来使用二分的技巧，l&#x3D;0，r&#x3D;1000，然后while循环二分查找直到l&gt;&#x3D;r。</p><p>如何查找？</p><p>就是用双向广搜，也就是从起点和窝同时进行广搜。</p><p>在进行双向bfs的过程中，vis的状态变成了0,1,2。</p><p>其中的0表示没有访问到，1表示这是起点过来访问到的，2表示窝过来访问到的。</p><p>bfs直到下一个点的状态（vis[nx][ny]）与当前点的状态（vis[x][y]）不相同，返回1。</p><p>（在这之前一定要判断vis[nx][ny]!&#x3D;0）</p><p>否则返回0。</p><h1 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">510</span>;<br><span class="hljs-type">int</span> n,m,dis_to_tree[MAXN][MAXN],startx,starty,endx,endy;<br><span class="hljs-type">int</span> vis[MAXN][MAXN];<br><span class="hljs-type">char</span> mp[MAXN][MAXN];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br><span class="hljs-type">int</span> x,y,to_tree_dis,type;<br>&#125;;<br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;,dy[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">search1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">memset</span>(dis_to_tree,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(dis_to_tree));<br><span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vis));<br>queue&lt;node&gt; q;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>&#123;<br><span class="hljs-keyword">if</span>(mp[i][j]==<span class="hljs-string">&#x27;+&#x27;</span>)<br>&#123;<br>dis_to_tree[i][j]=<span class="hljs-number">0</span>;<br>vis[i][j]=<span class="hljs-number">1</span>;<br>q.<span class="hljs-built_in">push</span>(&#123;i,j,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br>node top=q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-type">int</span> x=top.x,y=top.y;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<br>&#123;<br><span class="hljs-type">int</span> nx=x+dx[i],ny=y+dy[i];<br><span class="hljs-keyword">if</span>(nx&gt;=<span class="hljs-number">1</span>&amp;&amp;ny&gt;=<span class="hljs-number">1</span>&amp;&amp;nx&lt;=n&amp;&amp;ny&lt;=m&amp;&amp;!vis[nx][ny])<br>&#123;<br>dis_to_tree[nx][ny]=top.to_tree_dis<span class="hljs-number">+1</span>;<br>vis[nx][ny]=<span class="hljs-number">1</span>;<br>q.<span class="hljs-built_in">push</span>(&#123;nx,ny,dis_to_tree[nx][ny],<span class="hljs-number">0</span>&#125;);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> dis)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(dis==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vis));<br>queue&lt;node&gt; q;<br><span class="hljs-keyword">if</span>(dis_to_tree[startx][starty]&lt;dis||dis_to_tree[endx][endy]&lt;dis) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>q.<span class="hljs-built_in">push</span>(&#123;startx,starty,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;);<br>q.<span class="hljs-built_in">push</span>(&#123;endx,endy,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>&#125;);<br>vis[startx][starty]=<span class="hljs-number">1</span>;<br>vis[endx][endy]=<span class="hljs-number">2</span>;<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br>node top=q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-type">int</span> x=top.x,y=top.y;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<br>&#123;<br><span class="hljs-type">int</span> nx=x+dx[i],ny=y+dy[i];<br><span class="hljs-keyword">if</span>(nx&lt;<span class="hljs-number">1</span>||ny&lt;<span class="hljs-number">1</span>||nx&gt;n||ny&gt;m) <span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span>(dis_to_tree[nx][ny]&lt;dis) <span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span>(!vis[nx][ny])<br>&#123;<br>vis[nx][ny]=top.type;<br>q.<span class="hljs-built_in">push</span>(&#123;nx,ny,<span class="hljs-number">0</span>,top.type&#125;);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(vis[nx][ny]!=top.type)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>&#123;<br>cin&gt;&gt;mp[i][j];<br><span class="hljs-keyword">if</span>(mp[i][j]==<span class="hljs-string">&#x27;V&#x27;</span>) startx=i,starty=j;<br><span class="hljs-keyword">if</span>(mp[i][j]==<span class="hljs-string">&#x27;J&#x27;</span>) endx=i,endy=j;<br>&#125;<br>&#125;<br><span class="hljs-built_in">search1</span>();<br><span class="hljs-keyword">if</span>(startx==endx&amp;&amp;starty==endy)<br>&#123;<br>cout&lt;&lt;dis_to_tree[startx][starty]&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=<span class="hljs-number">1000</span>;<br><span class="hljs-keyword">while</span>(l&lt;r)<br>&#123;<br><span class="hljs-type">int</span> mid=(l+r<span class="hljs-number">+1</span>)&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">solve</span>(mid)) l=mid;<br><span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;<br>&#125;<br>cout&lt;&lt;l&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
