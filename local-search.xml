<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【学习笔记】模板综合</title>
    <link href="/2025/09/24/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%A8%A1%E6%9D%BF%E7%BB%BC%E5%90%88/"/>
    <url>/2025/09/24/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%A8%A1%E6%9D%BF%E7%BB%BC%E5%90%88/</url>
    
    <content type="html"><![CDATA[<p>这里是记录所有学过的模板的（好像还不会背啊）</p><h1 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h1><p><a href="https://www.luogu.com.cn/problem/B3647">link</a></p><p>给出一张由 $n$ 个点 $m$ 条边组成的无向图。</p><p>求出所有点对 $(i,j)$ 之间的最短路径。</p><h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入 #1"></a>输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出 #1"></a>输出 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>对于 $100%$ 的数据，$n \le 100$，$m \le 4500$，任意一条边的权值 $w$ 是正整数且 $1 \leqslant w \leqslant 1000$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//Floyd</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m,dis[<span class="hljs-number">110</span>][<span class="hljs-number">110</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>dis[i][j]=<span class="hljs-built_in">min</span>(dis[i][j],dis[i][k]+dis[k][j]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br><span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(dis));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>&#123;<br><span class="hljs-type">int</span> u,v,w;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w);<br>dis[u][v]=dis[v][u]=<span class="hljs-built_in">min</span>(dis[u][v],w);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)dis[i][i]=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">floyd</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,dis[i][j]);<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="缩点"><a href="#缩点" class="headerlink" title="缩点"></a>缩点</h1><p><a href="https://www.luogu.com.cn/problem/P3387">link</a></p><p>给定一个 $n$ 个点 $m$ 条边有向图，每个点有一个权值，求一条路径，使路径经过的点权值之和最大。你只需要求出这个权值和。</p><p>允许多次经过一条边或者一个点，但是，重复经过的点，权值只计算一次。</p><h3 id="输入-1-1"><a href="#输入-1-1" class="headerlink" title="输入 #1"></a>输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="输出-1-1"><a href="#输出-1-1" class="headerlink" title="输出 #1"></a>输出 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">2<br></code></pre></td></tr></table></figure><h1 id="ST-表-RMQ-问题"><a href="#ST-表-RMQ-问题" class="headerlink" title="ST 表 &amp; RMQ 问题"></a>ST 表 &amp; RMQ 问题</h1><p><a href="https://www.luogu.com.cn/problem/P3865">link</a></p><p>给定一个长度为 $N$ 的数列，和 $ M $ 次询问，求出每一次询问的区间内数字的最大值。</p><h3 id="输入-1-2"><a href="#输入-1-2" class="headerlink" title="输入 #1"></a>输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">8 </span><span class="hljs-number">8</span><br><span class="hljs-symbol">9 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">0</span> <span class="hljs-number">8</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">7</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">8</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">8</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">7</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><h3 id="输出-1-2"><a href="#输出-1-2" class="headerlink" title="输出 #1"></a>输出 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs">9<br>9<br>7<br>7<br>9<br>8<br>7<br>9<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//ST表</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> lg[<span class="hljs-number">100010</span>],f[<span class="hljs-number">100010</span>][<span class="hljs-number">30</span>],n,m;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span> (ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<br><span class="hljs-keyword">while</span> (ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<br><span class="hljs-keyword">return</span> x*f;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>n=<span class="hljs-built_in">read</span>(),m=<span class="hljs-built_in">read</span>();<br>lg[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)lg[i]=lg[i/<span class="hljs-number">2</span>]<span class="hljs-number">+1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>f[i][<span class="hljs-number">0</span>]=<span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=lg[n];j++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n-(<span class="hljs-number">1</span>&lt;&lt;j)<span class="hljs-number">+1</span>;i++)<br>f[i][j]=<span class="hljs-built_in">max</span>(f[i][j<span class="hljs-number">-1</span>],f[i+(<span class="hljs-number">1</span>&lt;&lt;(j<span class="hljs-number">-1</span>))][j<span class="hljs-number">-1</span>]);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>&#123;<br><span class="hljs-type">int</span> l=<span class="hljs-built_in">read</span>(),r=<span class="hljs-built_in">read</span>(),k=lg[r-l<span class="hljs-number">+1</span>];<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">max</span>(f[l][k],f[r-(<span class="hljs-number">1</span>&lt;&lt;k)<span class="hljs-number">+1</span>][k]));<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【百科】福州杨桥中学</title>
    <link href="/2025/09/04/%E3%80%90%E7%99%BE%E7%A7%91%E3%80%91%E7%A6%8F%E5%B7%9E%E6%9D%A8%E6%A1%A5%E4%B8%AD%E5%AD%A6/"/>
    <url>/2025/09/04/%E3%80%90%E7%99%BE%E7%A7%91%E3%80%91%E7%A6%8F%E5%B7%9E%E6%9D%A8%E6%A1%A5%E4%B8%AD%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p><img src="https://t15.baidu.com/it/u=3728413180,732842230&fm=224&app=112&f=JPEG?w=500&h=500"></p><p>​    福建省福州杨桥中学位于福州市中心，学校始建于1985年，占地面积18074平方米，建筑总面积14205平方米，学校规划布局合理，配套齐全。学校现有教职工132人，其中特级教师1人、高级教师12人、中级教师39人。具有本科学历的73人，专科学历40人；持有教师资格证书120人，全校共有省市级骨干教师35人；在校生1810人。学校以“三个代表”重要思想和邓小平“三个面向”为课程改革的指导思想，根据实际，提出“两全”、“两为”的办学理念，“两全”即面向全体学生，全面提高学生的整体素质；“两为”即领导为教师服务，教师为学生服务。提出争创“知名学校、省级达标”的办学目标。</p><table><thead><tr><th>中文名</th><th align="left">福建省福州杨桥中学</th><th>校训</th><th>仁、毅、智、诚</th></tr></thead><tbody><tr><td>简称</td><td align="left">福州杨桥中学</td><td>地址</td><td>鼓楼区学院路56号</td></tr><tr><td>所在地</td><td align="left">福建省福州市</td><td>主要奖项</td><td>福建省普通初中示范学校</td></tr><tr><td>创办时间</td><td align="left">1985年</td><td></td><td>国家安全教育示范校</td></tr><tr><td>办学性质</td><td align="left">公立中学</td><td>占地面积</td><td>$16903 m^2$</td></tr><tr><td>主管部门</td><td align="left">福州市鼓楼区教育</td><td>建筑面积</td><td>$15877m^2$</td></tr></tbody></table><h2 id="办学历史"><a href="#办学历史" class="headerlink" title="办学历史"></a>办学历史</h2><p>2001届为初中<a href="https://baike.baidu.com/item/%E4%BC%98%E7%A7%80%E7%8E%87/0?fromModule=lemma_inlink">优秀率</a>、巩固率、及格率是福州十三所达标中学中的一所。当年巩固率为99.6%，及格率98.7%（含保送）、优秀率为38.6%、高分率为13.3%。 [1]</p><p>2002届为初中巩固率、优秀率均达标的四所中学中的一所。当年巩固率为99.08%、及格率为93.58%、优秀率为39.53%、高分率为14.2%。</p><p>2003届巩固率为99.14%、及格率为92.07%、优秀率为40%、高分率为13.1%。</p><p>2004届巩固率为99.48%、及格率为93.21%、优秀率为47.3%、高分率为15.65%。</p><p>2002-2004学年以来，师生获奖情况：省级16人次、市级23人次、区级30人次。</p><p>2002-2004学年以来，教师论文获奖及发表情况：全国级有25篇，省级有10篇，市级有19篇，区级有24篇，另该校自行汇编了《探索》、《论文集》四本，《英语论文集》两本。</p><p>2002-2004，开展综合实践活动成果</p><p>在2003年底进行的省级综合实践活动评选中，罗清兰老师的一篇论文和一篇案例均获一等奖；刘政君老师的课例获一等奖论文获三等奖，俞繁老师的案例获省级三等奖。在2004年5月全国综合实验课例评比中获得可喜成绩：腾蓉老师的一篇课例获一等奖另一篇论文获二等奖；罗清兰老师的一篇课例获一等奖另一篇案例和两篇论文均获二等奖；刘政君老师的一篇课例获二等奖；郑宁老师的一篇论文获三等奖；杨明老师的一篇课例获省级三等奖。另罗清兰老师的论文《让学生成为实践活动课中真正的主体》一文发表在CN刊物上。</p><h2 id="文化传统"><a href="#文化传统" class="headerlink" title="文化传统"></a>文化传统</h2><p>学校秉持“尊重孩子发展的个体差异、尊重孩子独立成长的需要”的教育理念和“仁、毅、智、诚”校训认真办学 。校内设有剪纸社、合唱团、机器人社、信息学奥赛培训班等特色社团，还有读书月、合唱节、体育节、艺术节等活动平台，促进学生健康人格塑造和全面发展 。</p><h2 id="所获荣誉"><a href="#所获荣誉" class="headerlink" title="所获荣誉"></a>所获荣誉</h2><p>学校：连续二年获得“区教科研论文团体优胜奖”。还获得“市张思中教学先进实验校光荣称号”，“2001-2003年区科研先进单位”称号，由于近来教科研工作成绩显著，学校被推荐为“市课改先进实验校。”</p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><img src="https://picx.zhimg.com/v2-74028fe84c3fb9f54b180bbd420d405f_r.jpg?source=2c26e567"></p>]]></content>
    
    
    
    <tags>
      
      <tag>休闲娱乐</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【题解】洛谷P12085</title>
    <link href="/2025/08/31/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%B4%9B%E8%B0%B7P12085/"/>
    <url>/2025/08/31/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%B4%9B%E8%B0%B7P12085/</url>
    
    <content type="html"><![CDATA[<p><a href="http://luogu.com.cn/problem/P12085">题目传送门</a></p><p>借鉴这篇<a href="http://luogu.com.cn/article/nhijvm3v">题解</a>，dalao%%%</p><p>如果我们真的模拟的话肯定过不了的（<a href="https://www.luogu.com.cn/record/226752537">记录</a>）。</p><p>所以我们可以使用链表+优先队列的方式，来记录这个数列。</p><p>其中的删除操作也不是让我们真的删去，用版本（version）的方式记录当前数据能不能用，不能用就弹出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">500010</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-type">int</span> n,k;<br><span class="hljs-type">int</span> a[MAXN];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LIST</span><br>&#123;<br><span class="hljs-type">int</span> pre,nxt;<br>&#125;lst[MAXN];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br><span class="hljs-type">int</span> id;<br><span class="hljs-type">int</span> val;<br><span class="hljs-type">int</span> ver;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-type">const</span> node &amp;a)<span class="hljs-type">const</span><br>&#123;<br><span class="hljs-keyword">if</span>(val==a.val)<span class="hljs-keyword">return</span> id&gt;a.id;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> val&gt;a.val;<br>&#125;<br>&#125;;<br>priority_queue &lt;node&gt; q;<br><span class="hljs-type">int</span> v[MAXN];<br><span class="hljs-type">bool</span> isdel[MAXN];<span class="hljs-comment">//是否删除</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<br><span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c))<br>&#123;<br><span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>)f=<span class="hljs-number">-1</span>;<br>c=<span class="hljs-built_in">getchar</span>();<br>&#125;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c))<br>&#123;<br>x=x*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>;<br>c=<span class="hljs-built_in">getchar</span>();<br>&#125;<br><span class="hljs-keyword">return</span> x*f;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>)x=-x;<br><span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">10</span>)<span class="hljs-built_in">putchar</span>(x+<span class="hljs-string">&#x27;0&#x27;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">print</span>(x/<span class="hljs-number">10</span>),<span class="hljs-built_in">putchar</span>(x%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>n=<span class="hljs-built_in">read</span>(),k=<span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>&#123;<br>a[i]=<span class="hljs-built_in">read</span>();<br>q.<span class="hljs-built_in">push</span>(&#123;i,a[i],<span class="hljs-number">0</span>&#125;);<br>lst[i]=&#123;i<span class="hljs-number">-1</span>,i<span class="hljs-number">+1</span>&#125;;<span class="hljs-comment">//链表</span><br>&#125;<br>lst[<span class="hljs-number">1</span>].pre=lst[n].nxt=<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> vers=<span class="hljs-number">1</span>;vers&lt;=k;vers++)<br>&#123;<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()&amp;&amp;q.<span class="hljs-built_in">top</span>().ver!=v[q.<span class="hljs-built_in">top</span>().id])q.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//过期的数据弹出</span><br>node front=q.<span class="hljs-built_in">top</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-type">int</span> id=front.id;<br>isdel[id]=<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> val=front.val;<br><span class="hljs-type">int</span> pre=lst[id].pre,nxt=lst[id].nxt;<br><span class="hljs-keyword">if</span>(pre!=<span class="hljs-number">-1</span>)<br>&#123;<br>lst[pre].nxt=nxt;<br>a[pre]+=val;<br>q.<span class="hljs-built_in">push</span>(&#123;pre,a[pre],vers&#125;);<br>v[pre]=vers;<br>&#125;<br><span class="hljs-keyword">if</span>(nxt!=<span class="hljs-number">-1</span>)<br>&#123;<br>lst[nxt].pre=pre;<br>a[nxt]+=val;<br>q.<span class="hljs-built_in">push</span>(&#123;nxt,a[nxt],vers&#125;);<br>v[nxt]=vers;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br><span class="hljs-keyword">if</span>(!isdel[i])<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,a[i]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【题解】洛谷P2829</title>
    <link href="/2025/08/24/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%B4%9B%E8%B0%B7P2829/"/>
    <url>/2025/08/24/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%B4%9B%E8%B0%B7P2829/</url>
    
    <content type="html"><![CDATA[<p><a href="http://luogu.com.cn/problem/p2829">题目传送门</a></p><p>这道题和<a href="https://j27egu.github.io/2025/08/23/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%B4%9B%E8%B0%B7P2865/">P2865</a>一样，都是最短路。</p><p>只是在读入时统计度数，更新时增加判断：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(v!=<span class="hljs-number">1</span>&amp;&amp;v!=n&amp;&amp;deg[v]&lt;k)<span class="hljs-keyword">continue</span>;<br></code></pre></td></tr></table></figure><p>这道题就过了。</p><p>文章最短的一次……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">5010</span>,inf=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span><br>&#123;<br>    <span class="hljs-type">int</span> v,w;<br>&#125;;<br>vector &lt;edge&gt; g[MAXN];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br>    <span class="hljs-type">int</span> u,dis;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-type">const</span> node a)<span class="hljs-type">const</span> <br>    &#123;<br>        <span class="hljs-keyword">return</span> dis&gt;a.dis;<br>    &#125;<br>&#125;;<br><span class="hljs-type">int</span> dis[MAXN],ldis[MAXN],deg[MAXN],n,m,k;<br><span class="hljs-type">bool</span> vis[MAXN][MAXN];<br>priority_queue &lt;node&gt; q;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dis,inf,<span class="hljs-built_in">sizeof</span>(dis));<br>    <span class="hljs-built_in">memset</span>(ldis,inf,<span class="hljs-built_in">sizeof</span>(ldis));<br>    dis[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;);<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        node front=q.<span class="hljs-built_in">top</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> u=front.u;<br>        <span class="hljs-keyword">if</span>(front.dis&gt;ldis[u]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;g[u].<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            <span class="hljs-type">int</span> v=g[u][i].v,w=g[u][i].w;<br>            <span class="hljs-keyword">if</span>(v!=<span class="hljs-number">1</span>&amp;&amp;v!=n&amp;&amp;deg[v]&lt;k)<span class="hljs-keyword">continue</span>;<span class="hljs-comment">//这里增加判断！！！</span><br>            <span class="hljs-keyword">if</span>(front.dis+w&lt;dis[v])<br>            &#123;<br>                ldis[v]=dis[v];<br>                dis[v]=front.dis+w;<br>                q.<span class="hljs-built_in">push</span>(&#123;v,dis[v]&#125;);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(front.dis+w&gt;dis[v]&amp;&amp;front.dis+w&lt;ldis[v])<br>            &#123;<br>                ldis[v]=front.dis+w;<br>                q.<span class="hljs-built_in">push</span>(&#123;v,ldis[v]&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>),cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> u,v,w;<br>        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;<br>        g[u].<span class="hljs-built_in">push_back</span>(&#123;v,w&#125;);<br>        g[v].<span class="hljs-built_in">push_back</span>(&#123;u,w&#125;);<br>        <span class="hljs-keyword">if</span>(!vis[u][v])<br>        &#123;<span class="hljs-comment">//这里统计度数</span><br>            <span class="hljs-comment">//vis记录这个边是否有记录过，防止重边</span><br>            vis[u][v]=vis[v][u]=<span class="hljs-number">1</span>;<br>            deg[u]++,deg[v]++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">dijkstra</span>();<br>    <span class="hljs-keyword">if</span>(ldis[n]==inf)cout&lt;&lt;<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span> cout&lt;&lt;ldis[n];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【题解】洛谷P2865</title>
    <link href="/2025/08/23/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%B4%9B%E8%B0%B7P2865/"/>
    <url>/2025/08/23/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%B4%9B%E8%B0%B7P2865/</url>
    
    <content type="html"><![CDATA[<p><a href="http://luogu.com.cn/problem/P2865">题目传送门</a></p><p>我们可以用1次dijkstra解决这个问题。</p><p>每次读入队首进行更新时有三种情况：</p><p>1.更新最短路、次短路。</p><p>2.能更新次短路，但不能更新最短路。</p><p>3.啥也不能更新。</p><p>用dis代表最短路，ldis代表次短路。</p><p>在<code>q.top().dis+w&lt;dis[v]</code>时可以更新最短路和次短路：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ldis[v]=dis[v];<br>dis[v]=q.<span class="hljs-built_in">top</span>().dis+w;<br></code></pre></td></tr></table></figure><p>在<code>q.top().dis+w&gt;dis[v]&amp;&amp;q.top().dis+w&lt;ldis[v]</code>时可以更新次短路：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ldis[v]=q.<span class="hljs-built_in">top</span>().dis+w;<br></code></pre></td></tr></table></figure><p>哦，还有判断队首节点是否要继续更新的条件也要改成</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">front.dis&gt;ldis[u]<br></code></pre></td></tr></table></figure><p>不然就会跳过更新次短路。</p><p>以下是代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">5010</span>,inf=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span><br>&#123;<br><span class="hljs-type">int</span> v,w;<br>&#125;;<br>vector &lt;edge&gt; g[MAXN];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br><span class="hljs-type">int</span> u,dis;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-type">const</span> node a)<span class="hljs-type">const</span> <br>&#123;<br><span class="hljs-keyword">return</span> dis&gt;a.dis;<br>&#125;<br>&#125;;<br><span class="hljs-type">int</span> dis[MAXN],ldis[MAXN],n,m;<br>priority_queue &lt;node&gt; q;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">memset</span>(dis,inf,<span class="hljs-built_in">sizeof</span>(dis));<br><span class="hljs-built_in">memset</span>(ldis,inf,<span class="hljs-built_in">sizeof</span>(ldis));<br>dis[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;);<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br>node front=q.<span class="hljs-built_in">top</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-type">int</span> u=front.u;<br><span class="hljs-keyword">if</span>(front.dis&gt;ldis[u])<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;g[u].<span class="hljs-built_in">size</span>();i++)<br>&#123;<br><span class="hljs-type">int</span> v=g[u][i].v,w=g[u][i].w;<br><span class="hljs-keyword">if</span>(front.dis+w&lt;dis[v])<br>&#123;<br>ldis[v]=dis[v];<br>dis[v]=front.dis+w;<br>q.<span class="hljs-built_in">push</span>(&#123;v,dis[v]&#125;);<br>&#125;<br><span class="hljs-keyword">if</span>(front.dis+w&gt;dis[v]&amp;&amp;front.dis+w&lt;ldis[v])<br>&#123;<br>ldis[v]=front.dis+w;<br>q.<span class="hljs-built_in">push</span>(&#123;v,ldis[v]&#125;);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>),cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>&#123;<br><span class="hljs-type">int</span> u,v,w;<br>cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;<br>g[u].<span class="hljs-built_in">push_back</span>(&#123;v,w&#125;);<br>g[v].<span class="hljs-built_in">push_back</span>(&#123;u,w&#125;);<br>&#125;<br><span class="hljs-built_in">dijkstra</span>();<br>cout&lt;&lt;ldis[n];<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【题解】洛谷P2704</title>
    <link href="/2025/08/21/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%B4%9B%E8%B0%B7P2704/"/>
    <url>/2025/08/21/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%B4%9B%E8%B0%B7P2704/</url>
    
    <content type="html"><![CDATA[<p><a href="http://luogu.com.cn/problem/P2704">题目传送门</a></p><p>考虑到地形可以用二进制01表示，使用状压dp。</p><p>状压dp是采用十进制数字表示二进制的状态，实现状态的压缩。</p><p>如何设计状态，dp[层数][当前行的放置炮兵的情况][上一行放置炮兵的情况。</p><p>判断炮兵的放置情况要判断下面的情况是否合法：</p><ul><li>左移右移一位两位相与的结果要为0</li><li>放置情况与地形相与的结果要为0</li></ul><p>我们可以通过下面的代码来实现记录地形（grd数组）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>    &#123;<br>        <span class="hljs-type">char</span> tmp;<br>        cin&gt;&gt;tmp;<br>        grd[i]=(grd[i]&lt;&lt;<span class="hljs-number">1</span>)+(tmp==<span class="hljs-string">&#x27;H&#x27;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>为了不误伤友军，我们需要通过二进制的左移和右移来判断是否会误伤。</p><p>我们用以下的代码，通过can数组来记录这个状态是否可用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;m);i++)<br><span class="hljs-keyword">if</span>(!(i&amp;(i&lt;&lt;<span class="hljs-number">1</span>))&amp;&amp;!(i&amp;(i&lt;&lt;<span class="hljs-number">2</span>))&amp;&amp;!(i&amp;i&gt;&gt;<span class="hljs-number">1</span>)&amp;&amp;!(i&amp;i&gt;&gt;<span class="hljs-number">2</span>))<br>&#123;<br>can[i]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>((i&amp;grd[<span class="hljs-number">1</span>])==<span class="hljs-number">0</span>)dp[<span class="hljs-number">1</span>][i][<span class="hljs-number">0</span>]=<span class="hljs-built_in">res</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们还可以顺便把dp的第一层给搞定。</p><p>res(i)是用来计算i在二进制下1的个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i)<br>&#123;<br><span class="hljs-keyword">if</span>(i&amp;<span class="hljs-number">1</span>)cnt++;<br>i&gt;&gt;=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure><p>同理，我们通过枚举上一行和当前行的状态来进行dp。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//对第二行进行dp</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> A=<span class="hljs-number">0</span>;A&lt;(<span class="hljs-number">1</span>&lt;&lt;m);A++)<br><span class="hljs-keyword">if</span>(can[A]&amp;&amp;(A&amp;grd[<span class="hljs-number">1</span>])==<span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> B=<span class="hljs-number">0</span>;B&lt;(<span class="hljs-number">1</span>&lt;&lt;m);B++)<br><span class="hljs-keyword">if</span>(can[B]&amp;&amp;(B&amp;grd[<span class="hljs-number">2</span>])==<span class="hljs-number">0</span>&amp;&amp;(A&amp;B)==<span class="hljs-number">0</span>)<br>dp[<span class="hljs-number">2</span>][B][A]=dp[<span class="hljs-number">1</span>][A][<span class="hljs-number">0</span>]+<span class="hljs-built_in">res</span>(B);<br><span class="hljs-comment">//对3~n行进行dp</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=n;i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> A=<span class="hljs-number">0</span>;A&lt;(<span class="hljs-number">1</span>&lt;&lt;m);A++)<br><span class="hljs-keyword">if</span>(can[A]&amp;&amp;(A&amp;grd[i<span class="hljs-number">-2</span>])==<span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> B=<span class="hljs-number">0</span>;B&lt;(<span class="hljs-number">1</span>&lt;&lt;m);B++)<br><span class="hljs-keyword">if</span>(can[B]&amp;&amp;(B&amp;grd[i<span class="hljs-number">-1</span>])==<span class="hljs-number">0</span>&amp;&amp;(A&amp;B)==<span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> C=<span class="hljs-number">0</span>;C&lt;(<span class="hljs-number">1</span>&lt;&lt;m);C++)<br><span class="hljs-keyword">if</span>(can[C]&amp;&amp;(C&amp;grd[i])==<span class="hljs-number">0</span>&amp;&amp;(C&amp;A)==<span class="hljs-number">0</span>&amp;&amp;(C&amp;B)==<span class="hljs-number">0</span>)<br>dp[i][C][B]=<span class="hljs-built_in">max</span>(dp[i][C][B],dp[i<span class="hljs-number">-1</span>][B][A]+<span class="hljs-built_in">res</span>(C));<br></code></pre></td></tr></table></figure><p>后面用ans统计答案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;(<span class="hljs-number">1</span>&lt;&lt;m);j++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;(<span class="hljs-number">1</span>&lt;&lt;m);k++)<br>ans=<span class="hljs-built_in">max</span>(ans,dp[i][j][k]);<br></code></pre></td></tr></table></figure><p>相信大家的拼装能力肯定不错，能够把上面这些零件拼起来的。</p><h2 id="完整答案："><a href="#完整答案：" class="headerlink" title="完整答案："></a>完整答案：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m,grd[<span class="hljs-number">110</span>],dp[<span class="hljs-number">110</span>][(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">10</span>)][(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">10</span>)];<br><span class="hljs-type">bool</span> can[(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">10</span>)];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i)<br>&#123;<br><span class="hljs-keyword">if</span>(i&amp;<span class="hljs-number">1</span>)cnt++;<br>i&gt;&gt;=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> cnt;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>),cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>&#123;<br><span class="hljs-type">char</span> tmp;<br>cin&gt;&gt;tmp;<br>grd[i]=(grd[i]&lt;&lt;<span class="hljs-number">1</span>)+(tmp==<span class="hljs-string">&#x27;H&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;m);i++)<br><span class="hljs-keyword">if</span>(!(i&amp;(i&lt;&lt;<span class="hljs-number">1</span>))&amp;&amp;!(i&amp;(i&lt;&lt;<span class="hljs-number">2</span>))&amp;&amp;!(i&amp;i&gt;&gt;<span class="hljs-number">1</span>)&amp;&amp;!(i&amp;i&gt;&gt;<span class="hljs-number">2</span>))<br>&#123;<br>can[i]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>((i&amp;grd[<span class="hljs-number">1</span>])==<span class="hljs-number">0</span>)dp[<span class="hljs-number">1</span>][i][<span class="hljs-number">0</span>]=<span class="hljs-built_in">res</span>(i);<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> A=<span class="hljs-number">0</span>;A&lt;(<span class="hljs-number">1</span>&lt;&lt;m);A++)<br><span class="hljs-keyword">if</span>(can[A]&amp;&amp;(A&amp;grd[<span class="hljs-number">1</span>])==<span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> B=<span class="hljs-number">0</span>;B&lt;(<span class="hljs-number">1</span>&lt;&lt;m);B++)<br><span class="hljs-keyword">if</span>(can[B]&amp;&amp;(B&amp;grd[<span class="hljs-number">2</span>])==<span class="hljs-number">0</span>&amp;&amp;(A&amp;B)==<span class="hljs-number">0</span>)<br>dp[<span class="hljs-number">2</span>][B][A]=dp[<span class="hljs-number">1</span>][A][<span class="hljs-number">0</span>]+<span class="hljs-built_in">res</span>(B);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=n;i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> A=<span class="hljs-number">0</span>;A&lt;(<span class="hljs-number">1</span>&lt;&lt;m);A++)<br><span class="hljs-keyword">if</span>(can[A]&amp;&amp;(A&amp;grd[i<span class="hljs-number">-2</span>])==<span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> B=<span class="hljs-number">0</span>;B&lt;(<span class="hljs-number">1</span>&lt;&lt;m);B++)<br><span class="hljs-keyword">if</span>(can[B]&amp;&amp;(B&amp;grd[i<span class="hljs-number">-1</span>])==<span class="hljs-number">0</span>&amp;&amp;(A&amp;B)==<span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> C=<span class="hljs-number">0</span>;C&lt;(<span class="hljs-number">1</span>&lt;&lt;m);C++)<br><span class="hljs-keyword">if</span>(can[C]&amp;&amp;(C&amp;grd[i])==<span class="hljs-number">0</span>&amp;&amp;(C&amp;A)==<span class="hljs-number">0</span>&amp;&amp;(C&amp;B)==<span class="hljs-number">0</span>)<br>dp[i][C][B]=<span class="hljs-built_in">max</span>(dp[i][C][B],dp[i<span class="hljs-number">-1</span>][B][A]+<span class="hljs-built_in">res</span>(C));<br><span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;(<span class="hljs-number">1</span>&lt;&lt;m);j++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;(<span class="hljs-number">1</span>&lt;&lt;m);k++)<br>ans=<span class="hljs-built_in">max</span>(ans,dp[i][j][k]);<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【学习笔记】树上差分</title>
    <link href="/2025/07/29/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86/"/>
    <url>/2025/07/29/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>1.点差分</p><p>2.边差分</p><h2 id="边差分"><a href="#边差分" class="headerlink" title="边差分"></a>边差分</h2><p>对差分和差分数组的理解一般都是停留再数组这种线性结构上，这可能会导致学习树上差分的时候无法理解这个概念。</p><p>树上差分一般应用于在树上的路径统计。</p><p>对于一棵树，可以设置差分数组表示经过边$i$（边$i$的定义是连接$i$到$i$父亲的这条边）的次数。</p><p>进行边差分是一般是从叶子节点向根节点进行差分。</p><p>若要在$(u,v)$的路径上进行加$i$，那我们要在差分数组进行下面操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">d[u]+=i,d[v]+=i,d[<span class="hljs-built_in">lca</span>(u,v)]-=<span class="hljs-number">2</span>i;<br><span class="hljs-comment">//反之</span><br>d[u]-=i,d[v]-=i,d[<span class="hljs-built_in">lca</span>(u,v)]+=<span class="hljs-number">2</span>i;<br></code></pre></td></tr></table></figure><p>任意两点之间有且只有一条简单路径。</p><p>如果是一棵无根树，那么确定根节点后，出根节点外每个点有且只有一个父节点。</p><h2 id="点差分"><a href="#点差分" class="headerlink" title="点差分"></a>点差分</h2><p>对于图上的问题，有一些问题是带边权的，有一些问题则是带点权的。</p><p>对于这些问题，可以把两种权值相互转化，即边权转点权、点权转边权等操作。</p><p>但是其实有时候完全没有必要，点的差分数组比较好定义：</p><p>$d_i$表示$i$点一共被经过几次。那么对于路径$(u,v)$，就有以下的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">d[u]+=i,d[v]+=i,d[<span class="hljs-built_in">lca</span>(u,v)]-=i,d[fa[<span class="hljs-built_in">lca</span>(u,v)]]-=i;<br><span class="hljs-comment">//反之</span><br>d[u]-=i,d[v]-=i,d[<span class="hljs-built_in">lca</span>(u,v)]+=i,d[fa[<span class="hljs-built_in">lca</span>(u,v)]]+=i;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【学习笔记】子树和</title>
    <link href="/2025/07/29/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%AD%90%E6%A0%91%E5%92%8C/"/>
    <url>/2025/07/29/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%AD%90%E6%A0%91%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在数据结构中存在一种叫“树”的结构。</p><p>树的定义：树是由$n$个节点（或元素）组成的有限集合（记为$T$）。</p><ul><li><p>如果$n&#x3D;0$，它是一棵空树。</p></li><li><p>如果$n&gt;0$，这个n个节点有且仅有一个节点作为树的根节点，简称为跟，其余节点可分为$m(m\leq 0)$个互不相干的有限集合$T1,T2\cdots$，其中，每个自己不呢神是一棵符合定义的树，成为根节点的子树。</p></li></ul><h2 id="求二叉树的最大子树和"><a href="#求二叉树的最大子树和" class="headerlink" title="求二叉树的最大子树和"></a>求二叉树的最大子树和</h2><p><a href="http://luogu.com.cn/problem/P1122">p_lnk</a></p><p>通过递归树形dp，求以$u$为根的最大值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">100010</span>;<br>vector &lt;<span class="hljs-type">int</span>&gt; g[MAXN];<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll w[MAXN],dp[MAXN];<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>dp[u]=w[u];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> v:g[u])<br>&#123;<br><span class="hljs-keyword">if</span>(v==fa)<span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">dfs</span>(v,u);<br>dp[u]+=<span class="hljs-built_in">max</span>(dp[v],<span class="hljs-number">0LL</span>);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)cin&gt;&gt;w[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)<br>&#123;<br><span class="hljs-type">int</span> u,v;<br>cin&gt;&gt;u&gt;&gt;v;<br>g[u].<span class="hljs-built_in">push_back</span>(v);<br>g[v].<span class="hljs-built_in">push_back</span>(u);<br>&#125;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>cout&lt;&lt;*<span class="hljs-built_in">max_element</span>(dp<span class="hljs-number">+1</span>,dp+n<span class="hljs-number">+1</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【学习笔记】单源次短路径</title>
    <link href="/2025/07/27/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%8D%95%E6%BA%90%E6%AC%A1%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <url>/2025/07/27/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%8D%95%E6%BA%90%E6%AC%A1%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>通过改进dijkstra的更新逻辑来实现单源次短路径。</p><p>当我们从队首得到一个新的点$u$和$s$到$u$的距离$d$时，会有以下三种情况：</p><p>其中的$d_i$表示$s$到$i$的最短路径，$ld_i$表示$s$到$i$的次短路径。</p><ul><li>$dis &lt; d_u$，可以更新最短路和次短路，那么次短路更新成原来的最短路，然后更新最短路。</li><li>$d_i &lt; dis &lt; ld_i$，可以更新次短路，直接更新。</li><li>$dis &gt; ld_i$，都更新不了。</li></ul><p>根据这个逻辑，我们就能够做好啦！</p><p><a href="http://j27egu.github.io/2025/08/23/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%B4%9B%E8%B0%B7P2865">代码+例题</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【题解】洛谷P1729</title>
    <link href="/2025/07/25/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%B4%9B%E8%B0%B7P1729/"/>
    <url>/2025/07/25/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%B4%9B%E8%B0%B7P1729/</url>
    
    <content type="html"><![CDATA[<p><a href="http://luogu.com.cn/problem/P1729">题目传送门</a></p><p>由于我不会写高精度，只好打表。</p><p><a href="https://www.cnblogs.com/Xsmyy/p/13458500.html">lnk</a></p><p>（正好有一篇博客就是记录$e$的$10000$位，直接ctrl+c，ctrl+v！）</p><p>可谓：</p><blockquote><p>小巧玲珑，短小精悍。</p></blockquote><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>string s=<span class="hljs-string">&quot;7182818284590452353602874713526624977572470936999595749669676277240766303535475945713821785251664274274663919320030599218174135966290435729003342952605956307381323286279434907632338298807531952510190115738341879307021540891499348841675092447614606680822648001684774118537423454424371075390777449920695517027618386062613313845830007520449338265602976067371132007093287091274437470472306969772093101416928368190255151086574637721112523897844250569536967707854499699679468644549059879316368892300987931277361782154249992295763514822082698951936680331825288693984964651058209392398294887933203625094431173012381970684161403970198376793206832823764648042953118023287825098194558153017567173613320698112509961818815930416903515988885193458072738667385894228792284998920868058257492796104841984443634632449684875602336248270419786232090021609902353043699418491463140934317381436405462531520961836908887070167683964243781405927145635490613031072085103837505101157477041718986106873969655212671546889570350354021234078498193343210681701210056278802351930332247450158539047304199577770935036604169973297250886876966403555707162268447162560798826517871341951246652010305921236677194325278675398558944896970964097545918569563802363701621120477427228364896134225164450781824423529486363721417402388934412479635743702637552944483379980161254922785092577825620926226483262779333865664816277251640191059004916449982893150566047258027786318641551956532442586982946959308019152987211725563475463964479101459040905862984967912874068705048958586717479854667757573205681288459205413340539220001137863009455606881667400169842055804033637953764520304024322566135278369511778838638744396625322498506549958862342818997077332761717839280349465014345588970719425863987727547109629537415211151368350627526023264847287039207643100595841166120545297030236472549296669381151373227536450988890313602057248176585118063036442812314965507047510254465011727211555194866850800368532281831521960037356252794495158284188294787610852639813955990067376482922443752871846245780361929819713991475644882626039033814418232625150974827987779964373089970388867782271383605772978824125611907176639465070633045279546618550966661856647097113444740160704626215680717481877844371436988218559670959102596862002353718588748569652200050311734392073211390803293634479727355955277349071783793421637012050054513263835440001863239914907054797780566978533580489669062951194324730995876552368128590413832411607226029983305353708761389396391779574540161372236187893652605381558415871869255386061647798340254351284396129460352913325942794904337299085731580290958631382683291477116396337092400316894586360606458459251269946557248391865642097526850823075442545993769170419777800853627309417101634349076964237222943523661255725088147792231519747780605696725380171807763603462459278778465850656050780844211529697521890874019660906651803516501792504619501366585436632712549639908549144200014574760819302212066024330096412704894390397177195180699086998606636583232278709376502260149291011517177635944602023249300280401867723910288097866605651183260043688508817157238669842242201024950551881694803221002515426494639812873677658927688163598312477886520141174110913601164995076629077943646005851941998560162647907615321038727557126992518275687989302761761146162549356495903798045838182323368612016243736569846703785853305275833337939907521660692380533698879565137285593883499894707416181550125397064648171946708348197214488898790676503795903669672494992545279033729636162658976039498576741397359441023744329709355477982629614591442936451428617158587339746791897571211956187385783644758448423555581050025611492391518893099463428413936080383091662818811503715284967059741625628236092168075150177725387402564253470879089137291722828611515915683725241630772254406337875931059826760944203261924285317018781772960235413060672136046000389661093647095141417185777014180606443636815464440053316087783143174440811949422975599314011888683314832802706553833004693290115744147563139997221703804617092894579096271662260740718749975359212756084414737823303270330168237193648002173285734935947564334129943024850235732214597843282641421684878721673367010615094243456984401873312810107945127223737886126058165668053714396127888732527373890392890506865324138062796025930387727697783792868409325365880733988457218746021005311483351323850047827169376218004904795597959290591655470505777514308175112698985188408718564026035305583737832422924185625644255022672155980274012617971928047139600689163828665277009752767069777036439260224372841840883251848770472638440379530166905465937461619323840363893131364327137688841026811219891275223056256756254701725086349765367288605966752740868627407912856576996313789753034660616669804218267724560530660773899624218340859882071864682623215080288286359746839654358856685503773131296587975810501214916207656769950659715344763470320853215603674828608378656803073062657633469774295634643716709397193060876963495328846833613038829431040800296873869117066666146800015121143442256023874474325250769387077775193299942137277211258843608715834835626961661980572526612206797540621062080649882918454395301529982092503005498257043390553570168653120526495614857249257386206917403695213533732531666345466588597286659451136441370331393672118569553952108458407244323835586063106806964924851232632699514603596037297253198368423363904632136710116192821711150282801604488058802382031981493096369596735832742024988245684941273860566491352526706046234450549227581151709314921879592718001940968866986837037302200475314338181092708030017205935530520700706072233999463990571311587099635777359027196285061146514837526209565346713290025994397663114545902685898979115837093419370441155121920117164880566945938131183843765620627846310490346293950029458341164824114969758326011800731699437393506966295712410273239138741754923071862454543222039552735295240245903805744502892246886285336542213815722131163288112052146489805180092024719391710555390113943316681515828843687606961102505171007392762385553386272553538830960671644662370922646809671254061869502143176211668140097595281493907222601112681153108387317617323235263605838173151034595736538223534992935822836851007810884634349983518404451704270189381994243410090575376257767571118090088164183319201962623416288166521374717325477727783488774366518828752156685719506371936565390389449366421764003121527870222366463635755503565576948886549500270853923617105502131147413744106134445544192101336172996285694899193369184729478580729156088510396781959429833186480756083679551496636448965592948187851784038773326247051945050419847742014183947731202815886845707290544057510601285258056594703046836344592652552137008068752009593453607316226118728173928074623094685367823106097921599360019946237993434210687813497346959246469752506246958616909178573976595199392993995567542714654910456860702099012606818704984178079173924071945996323060254707901774527513186809982284730860766536866855516467702911336827563107223346726113705490795365834538637196235856312618387156774118738527722922594743373785695538456246801013905727871016512966636764451872465653730402443684140814488732957847348490003019477888020460324660842875351848364959195082888323206522128104190448047247949291342284951970022601310430062410717971502793433263407995960531446053230488528972917659876016667811937932372453857209607582277178483361613582612896226118129455927462767137794487586753657544861407611931125958512655759734573015333642630767985443385761715333462325270572005303988289499034259566232975782488735029259166825894456894655992658454762694528780516501720674785417887982276806536650641910973434528878338621726156269582654478205672987756426325321594294418039943217000090542650763095588465895171709147607437136893319469090981904501290307099566226620303182649365733698419555776963787624918852865686607600566025605445711337286840205574416030837052312242587223438854123179481388550075689381124935386318635287083799845692619981794523364087429591180747453419551420351726184200845509170845682368200897739455842679214273477560879644279202708312150156406341341617166448069815483764491573900121217041547872591998943825364950514771379399147205219529079396137621107238494290616357604596231253506068537651423115349665683715116604220796394466621163255157729070978473156278277598788136491951257483328793771571459091064841642678309949723674420175862269402159407924480541255360431317992696739157542419296607312393763542139230617876753958711436104089409966089471418340698362993675362621545247298464213752891079884381306095552622720837518629837066787224430195793793786072107254277289071732854874374355781966511716618330881129120245204048682200072344035025448202834254187884653602591506445271657700044521097735585897622655484941621714989532383421600114062950718490427789258552743035221396835679018076406042138307308774460170842688272261177180842664333651780002171903449234264266292261456004337383868335555343453004264818473989215627086095650629340405264943244261445665921291225648893569655009154306426134252668472594914314239398845432486327461842846655985332312210466259890141712103446084271616619001257195870793217569698544013397622096749454185407118446433946990162698351607848924514058940946395267807354579700307051163682519487701189764002827648414160587206184185297189154019688253289309149665345753571427318482016384644832499037886069008072709327673127581966563941148961716832980455139729506687604740915420428429993541025829113502241690769431668574242522509026939034814856451303069925199590436384028429267412573422447765584177886171737265462085498294498946787350929581652632072258992368768457017823038096567883112289305809140572610865884845873101658151167533327674887014829167419701512559782572707406431808601428149024146780472327597684269633935773542930186739439716388611764209004068663398856841681003872389214483176070116684503887212364367043314091155733280182977988736590916659612402021778558854876176161989370794380056663364884365089144805571039765214696027662583599051987042300179465536788&quot;</span>;<br><span class="hljs-type">int</span> n;<br>cin&gt;&gt;n;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;2.\n&quot;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>&#123;<br>cout&lt;&lt;s[i<span class="hljs-number">-1</span>];<br><span class="hljs-keyword">if</span>(i%<span class="hljs-number">50</span>==<span class="hljs-number">0</span>)<span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i%<span class="hljs-number">10</span>==<span class="hljs-number">0</span>)<span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>非常不推荐这种做法，<del>（但是我还是赛时用了o(<em>￣▽￣</em>)ブ）</del></p>]]></content>
    
    
    
    <tags>
      
      <tag>休闲娱乐</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【学习笔记】线段树</title>
    <link href="/2025/07/25/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <url>/2025/07/25/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>线段树是一种二叉搜索树，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶子节点。</p><p>使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度未$O(\log n)$。而未优化的空间复杂度为$2N$，实际应用是一般还要开$4N$，的数组以免越界，因此有时需要离散化让空间压缩。</p><p>树的形态一般如下：（引用自OI-WIKI）</p><img src="https://oi-wiki.org/ds/images/segt1.svg" style="zoom:50%;" /><p>对于线段树中的每一个非叶子节点$[a,b]$，它的左儿子表示区间为$[a,\frac{a+b}{2}]$，它的右儿子表示的区间为$[\frac{a+b}{2}+1,b]$。因此线段树是平衡二叉树，最后的子节点数目为$N$，即整个线段区间的长度。</p><p>使用线段树可以快速查找某一个节点在若干条线段中出现的次数，时间复杂度为$O(\log 2n)$。而为优化的空间复杂度为$T(2N)$，因此有时需要离散化进行空间压缩。</p><p>图片举例（引用自CSDN la_alweq）</p><p>每个节点存什么，节点下标是什么，如何建树？</p><p><a href="https://i-blog.csdnimg.cn/blog_migrate/8e64e93c7a590efe8490c43c052406df.png">pic_lnk</a></p><img src="https://i-blog.csdnimg.cn/blog_migrate/8e64e93c7a590efe8490c43c052406df.png" style="zoom:50%;" /><p>该数组为$a&#x3D;{1,8,6,4,3,5}$，红色代表节点存储的区间，蓝色表示该区间内的最大值。</p><p>每个叶子节点的值，就是数组的值，每个非叶子节点的度都为二，且左右两个孩子分别存储父亲一般的区间。</p><p>每个父亲存储的值也就是两个孩子存储的值的最大值。</p><p>如何快速找到非叶子节点的孩子以及非根节点的父亲？</p><p>对于一个区间$[l,r]$来说，最重要的数据当然就是区间的做右端点$l$和$r$，但是大部分的情况我们并不会去存储这两个数值，而是通过递归的传参方式进行传递。</p><p>这种方式用指针很好实现，定义两个左右子树递归即可，但是指针表示过于繁琐，而且不方便各种操作，大部分线段树都是使用数组进行表示，快速使用下标找到左右子树。</p><p>图片举例（引用自CSDN la_alweq）</p><p><a href="https://i-blog.csdnimg.cn/blog_migrate/3e23057c9052f59c9a96cb7373d71b37.png">pic_lnk</a></p><img src="https://i-blog.csdnimg.cn/blog_migrate/3e23057c9052f59c9a96cb7373d71b37.png" style="zoom:50%;" /><p>其中的绿色是下表编号。</p><p>在最下排的编号从$9$直接到$12$，中间其实有两个空间。虽然没有使用，但还是存在。所以无优化的线段树开到$4N$才能防止RE。</p><p>每个父亲和孩子下标的关系如下：</p><ul><li>每个左子树的下标都是偶数，右子树的下标都是奇数。</li><li>父亲节点是儿子节点的一半，向下取整。</li><li>儿子节点是父亲节点的两倍，或加一。</li></ul><p>把线段树看作一个完全二叉树，空节点也当作使用。</p><p>根据奇怪的规律<del>（不支持md所以省略）</del>很简单就得到右子树节点为左子树节点数加一。</p><p><del>（这一段是什么用处呢？）</del></p><p>因为左子树都是偶数，所以我们常用位运算来寻寻找左右子树。</p><ul><li>k&lt;&lt;1，节点$k$的左子树下标。</li><li>k&lt;&lt;1|1，节点$k$的右子树下标。</li></ul><p>假如要修改$a[3]$，则包含此值的节点都需要更新。</p><p>根据二叉树的性质，$\log k$个节点都需要进行更新，这也正是为什么每次更新的时间复杂度为$O(\log n)$。</p><p>可以发现无论更新那个叶子节点，最终都会回到根节点，而把这个往上推的过程逆过来就是从根节点进行递归处理。</p><p>以下面的图为例（引用自CSDN la_alweq）</p><p><a href="https://i-blog.csdnimg.cn/blog_migrate/f2de351965c5ecdab7a635025be5de68.png">pic_lnk</a></p><img src="https://i-blog.csdnimg.cn/blog_migrate/f2de351965c5ecdab7a635025be5de68.png" style="zoom:50%;" /><p>线段树的每个节点存储的都是一段区间的信息，如果刚好要查询这个节点，那么则直接返回这个节点的信息即可，比如直接查询$[1,6]$这个区间的最值，那么直接返回根节点信息$13$。</p><p>若要查询区间$[2,5]$，那我们只需要查询$[2,2]，[3,3]，[4,5]$，三个区间。$[4,4]，[5,5]$不需要查找，包含在$[4,5]$中了。</p><p>$[2,5]$一共五个区间，而且发现$[4,5]$这个区间已经包含了$[4,4]，[5,5]$两个子树的信息，所以需要查询的区间只有三个，是$[2,2]，[3,3]，[4,5]$。</p><p>可以通过更新的思路想出来查询的思路，从根节点开始往下递归，时间复杂度$O(\log n)$。</p><p>线段树的区间更新使用差分的思想。</p><p>传统上，对于区间$[l,r]$，可能每次都更新区间中的每个值，更新的复杂度将会是$O(n\log n)$，造成浪费。</p><p>在进行区间更新是，引用lazy标记，提高更新的效率。</p><p>如果当前区间被需要修改的目标区间完全覆盖，则在被更新节点上打lazy标记，此区间不向下传导，这样的搭配使区间更新的操作和区间查询类似，复杂度为$O(\log n)$。</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【题解】洛谷P7775</title>
    <link href="/2025/07/23/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%B4%9B%E8%B0%B7P7775/"/>
    <url>/2025/07/23/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%B4%9B%E8%B0%B7P7775/</url>
    
    <content type="html"><![CDATA[<p>感谢@<a href="https://www.luogu.com.cn/user/1392775">xiejinghan</a><del>在赛时</del>给我分享思路。</p><p><a href="http://luogu.com.cn/problem/P7775">题目传送门</a></p><h2 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h2><p>在一个二维矩阵上面，从<code>V</code>到<code>J</code>的路径中，求离<code>+</code>的最短距离。</p><h2 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h2><p>题目中写<code>离它最近的树的距离的最小值</code>，很明显就能想到二分。</p><p>在读入数据时，用<code>startx</code>和<code>starty</code>标记起点的坐标。</p><p>同时，用<code>endx</code>和<code>endy</code>标记窝的坐标。</p><p>这里$dtt_{i,j}$表示$i,j$到树的最短距离</p><p>接着，使用bfs的方式，对$dtt$进行处理。</p><p>（顾名思义，$dtt_{i,j}$就是坐标$i,j$的点到最近的一棵树的最短距离）</p><p>然后特判，如果起点和窝的位置重合，就直接输出$dtt_{startx,starty}$。</p><p>接下来使用二分的技巧，$l&#x3D;0,r&#x3D;1000$，然后while循环二分查找直到$l \geq r$。</p><p>如何查找？</p><p>就是用双向广搜，也就是从起点和窝同时进行广搜。</p><p>在进行双向bfs的过程中，vis的状态变成了$0,1,2$。</p><p>其中的$0$表示没有访问到，$1$表示这是起点过来访问到的，$2$表示窝过来访问到的。</p><p>bfs直到下一个点的状态（$vis_{nx,ny}$）与当前点的状态（$vis_{x,y}$）不相同，返回$1$。</p><p>（在这之前一定要判断$vis_{nx,ny} \neq 0$）</p><p>否则返回$0$。</p><h2 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">510</span>;<br><span class="hljs-type">int</span> n,m,dis_to_tree[MAXN][MAXN],startx,starty,endx,endy;<br><span class="hljs-type">int</span> vis[MAXN][MAXN];<br><span class="hljs-type">char</span> mp[MAXN][MAXN];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br><span class="hljs-type">int</span> x,y,to_tree_dis,type;<br>&#125;;<br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;,dy[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">search1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">memset</span>(dis_to_tree,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(dis_to_tree));<br><span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vis));<br>queue&lt;node&gt; q;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>&#123;<br><span class="hljs-keyword">if</span>(mp[i][j]==<span class="hljs-string">&#x27;+&#x27;</span>)<br>&#123;<br>dis_to_tree[i][j]=<span class="hljs-number">0</span>;<br>vis[i][j]=<span class="hljs-number">1</span>;<br>q.<span class="hljs-built_in">push</span>(&#123;i,j,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br>node top=q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-type">int</span> x=top.x,y=top.y;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<br>&#123;<br><span class="hljs-type">int</span> nx=x+dx[i],ny=y+dy[i];<br><span class="hljs-keyword">if</span>(nx&gt;=<span class="hljs-number">1</span>&amp;&amp;ny&gt;=<span class="hljs-number">1</span>&amp;&amp;nx&lt;=n&amp;&amp;ny&lt;=m&amp;&amp;!vis[nx][ny])<br>&#123;<br>dis_to_tree[nx][ny]=top.to_tree_dis<span class="hljs-number">+1</span>;<br>vis[nx][ny]=<span class="hljs-number">1</span>;<br>q.<span class="hljs-built_in">push</span>(&#123;nx,ny,dis_to_tree[nx][ny],<span class="hljs-number">0</span>&#125;);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> dis)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(dis==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vis));<br>queue&lt;node&gt; q;<br><span class="hljs-keyword">if</span>(dis_to_tree[startx][starty]&lt;dis||dis_to_tree[endx][endy]&lt;dis) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>q.<span class="hljs-built_in">push</span>(&#123;startx,starty,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;);<br>q.<span class="hljs-built_in">push</span>(&#123;endx,endy,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>&#125;);<br>vis[startx][starty]=<span class="hljs-number">1</span>;<br>vis[endx][endy]=<span class="hljs-number">2</span>;<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br>node top=q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-type">int</span> x=top.x,y=top.y;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<br>&#123;<br><span class="hljs-type">int</span> nx=x+dx[i],ny=y+dy[i];<br><span class="hljs-keyword">if</span>(nx&lt;<span class="hljs-number">1</span>||ny&lt;<span class="hljs-number">1</span>||nx&gt;n||ny&gt;m) <span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span>(dis_to_tree[nx][ny]&lt;dis) <span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span>(!vis[nx][ny])<br>&#123;<br>vis[nx][ny]=top.type;<br>q.<span class="hljs-built_in">push</span>(&#123;nx,ny,<span class="hljs-number">0</span>,top.type&#125;);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(vis[nx][ny]!=top.type)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>&#123;<br>cin&gt;&gt;mp[i][j];<br><span class="hljs-keyword">if</span>(mp[i][j]==<span class="hljs-string">&#x27;V&#x27;</span>) startx=i,starty=j;<br><span class="hljs-keyword">if</span>(mp[i][j]==<span class="hljs-string">&#x27;J&#x27;</span>) endx=i,endy=j;<br>&#125;<br>&#125;<br><span class="hljs-built_in">search1</span>();<br><span class="hljs-keyword">if</span>(startx==endx&amp;&amp;starty==endy)<br>&#123;<br>cout&lt;&lt;dis_to_tree[startx][starty]&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=<span class="hljs-number">1000</span>;<br><span class="hljs-keyword">while</span>(l&lt;r)<br>&#123;<br><span class="hljs-type">int</span> mid=(l+r<span class="hljs-number">+1</span>)&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">solve</span>(mid)) l=mid;<br><span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;<br>&#125;<br>cout&lt;&lt;l&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
